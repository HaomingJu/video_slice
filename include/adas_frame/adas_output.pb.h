// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: adas_output.proto

#ifndef PROTOBUF_adas_5foutput_2eproto__INCLUDED
#define PROTOBUF_adas_5foutput_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace AdasOutputProtocol {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_adas_5foutput_2eproto();
void protobuf_AssignDesc_adas_5foutput_2eproto();
void protobuf_ShutdownFile_adas_5foutput_2eproto();

class GroundPoint;
class Rect;
class CameraInfo;
class ImageFrame;
class GPS;
class Motion;
class Line;
class Object;
class HMW;
class FCW;
class PCW;
class LDW;
class WarningResult;
class AdasOutput;

enum HMW_HmwLevel {
  HMW_HmwLevel_kHmwLevel_None = 0,
  HMW_HmwLevel_kHmwLevel_NoticeLevel1 = 1,
  HMW_HmwLevel_kHmwLevel_NoticeLevel2 = 2,
  HMW_HmwLevel_kHmwLevel_WarningLevel1 = 11,
  HMW_HmwLevel_kHmwLevel_WarningLevel2 = 12
};
bool HMW_HmwLevel_IsValid(int value);
const HMW_HmwLevel HMW_HmwLevel_HmwLevel_MIN = HMW_HmwLevel_kHmwLevel_None;
const HMW_HmwLevel HMW_HmwLevel_HmwLevel_MAX = HMW_HmwLevel_kHmwLevel_WarningLevel2;
const int HMW_HmwLevel_HmwLevel_ARRAYSIZE = HMW_HmwLevel_HmwLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* HMW_HmwLevel_descriptor();
inline const ::std::string& HMW_HmwLevel_Name(HMW_HmwLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    HMW_HmwLevel_descriptor(), value);
}
inline bool HMW_HmwLevel_Parse(
    const ::std::string& name, HMW_HmwLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<HMW_HmwLevel>(
    HMW_HmwLevel_descriptor(), name, value);
}
enum FCW_FcwLevel {
  FCW_FcwLevel_kFcwLevel_None = 0,
  FCW_FcwLevel_kFcwLevel_Warning = 1
};
bool FCW_FcwLevel_IsValid(int value);
const FCW_FcwLevel FCW_FcwLevel_FcwLevel_MIN = FCW_FcwLevel_kFcwLevel_None;
const FCW_FcwLevel FCW_FcwLevel_FcwLevel_MAX = FCW_FcwLevel_kFcwLevel_Warning;
const int FCW_FcwLevel_FcwLevel_ARRAYSIZE = FCW_FcwLevel_FcwLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* FCW_FcwLevel_descriptor();
inline const ::std::string& FCW_FcwLevel_Name(FCW_FcwLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    FCW_FcwLevel_descriptor(), value);
}
inline bool FCW_FcwLevel_Parse(
    const ::std::string& name, FCW_FcwLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FCW_FcwLevel>(
    FCW_FcwLevel_descriptor(), name, value);
}
enum PCW_PcwLevel {
  PCW_PcwLevel_kPcwLevel_None = 0,
  PCW_PcwLevel_kPcwLevel_Warning = 1
};
bool PCW_PcwLevel_IsValid(int value);
const PCW_PcwLevel PCW_PcwLevel_PcwLevel_MIN = PCW_PcwLevel_kPcwLevel_None;
const PCW_PcwLevel PCW_PcwLevel_PcwLevel_MAX = PCW_PcwLevel_kPcwLevel_Warning;
const int PCW_PcwLevel_PcwLevel_ARRAYSIZE = PCW_PcwLevel_PcwLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* PCW_PcwLevel_descriptor();
inline const ::std::string& PCW_PcwLevel_Name(PCW_PcwLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    PCW_PcwLevel_descriptor(), value);
}
inline bool PCW_PcwLevel_Parse(
    const ::std::string& name, PCW_PcwLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PCW_PcwLevel>(
    PCW_PcwLevel_descriptor(), name, value);
}
enum LDW_LdwLevel {
  LDW_LdwLevel_kLdwLevel_None = 0,
  LDW_LdwLevel_kLdwLevel_WarningLeftSide = 1,
  LDW_LdwLevel_kLdwLevel_WarningRightSide = 2
};
bool LDW_LdwLevel_IsValid(int value);
const LDW_LdwLevel LDW_LdwLevel_LdwLevel_MIN = LDW_LdwLevel_kLdwLevel_None;
const LDW_LdwLevel LDW_LdwLevel_LdwLevel_MAX = LDW_LdwLevel_kLdwLevel_WarningRightSide;
const int LDW_LdwLevel_LdwLevel_ARRAYSIZE = LDW_LdwLevel_LdwLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* LDW_LdwLevel_descriptor();
inline const ::std::string& LDW_LdwLevel_Name(LDW_LdwLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    LDW_LdwLevel_descriptor(), value);
}
inline bool LDW_LdwLevel_Parse(
    const ::std::string& name, LDW_LdwLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LDW_LdwLevel>(
    LDW_LdwLevel_descriptor(), name, value);
}
enum ImageFormat {
  GRAY = 0,
  YUV = 1,
  JPEG = 2,
  PNG = 3
};
bool ImageFormat_IsValid(int value);
const ImageFormat ImageFormat_MIN = GRAY;
const ImageFormat ImageFormat_MAX = PNG;
const int ImageFormat_ARRAYSIZE = ImageFormat_MAX + 1;

const ::google::protobuf::EnumDescriptor* ImageFormat_descriptor();
inline const ::std::string& ImageFormat_Name(ImageFormat value) {
  return ::google::protobuf::internal::NameOfEnum(
    ImageFormat_descriptor(), value);
}
inline bool ImageFormat_Parse(
    const ::std::string& name, ImageFormat* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ImageFormat>(
    ImageFormat_descriptor(), name, value);
}
enum LineType {
  LINE_RAW = 0,
  LINE_LEFT = 1,
  LINE_RIGHT = 2,
  LINE_LEFT_LEFT = 4,
  LINE_RIGHT_RIGHT = 8,
  LINE_DASH = 1024,
  LINE_SOLID = 2048
};
bool LineType_IsValid(int value);
const LineType LineType_MIN = LINE_RAW;
const LineType LineType_MAX = LINE_SOLID;
const int LineType_ARRAYSIZE = LineType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LineType_descriptor();
inline const ::std::string& LineType_Name(LineType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LineType_descriptor(), value);
}
inline bool LineType_Parse(
    const ::std::string& name, LineType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LineType>(
    LineType_descriptor(), name, value);
}
enum FunctionStatus {
  kStatus_Disable = 0,
  kStatus_Enable = 1,
  kStatus_Inhibit = 2,
  kStatus_Failed = 3
};
bool FunctionStatus_IsValid(int value);
const FunctionStatus FunctionStatus_MIN = kStatus_Disable;
const FunctionStatus FunctionStatus_MAX = kStatus_Failed;
const int FunctionStatus_ARRAYSIZE = FunctionStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* FunctionStatus_descriptor();
inline const ::std::string& FunctionStatus_Name(FunctionStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    FunctionStatus_descriptor(), value);
}
inline bool FunctionStatus_Parse(
    const ::std::string& name, FunctionStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<FunctionStatus>(
    FunctionStatus_descriptor(), name, value);
}
enum WarningLevel {
  kWarningLevel_None = 0,
  kWarningLevel_NoticeLevel1 = 1,
  kWarningLevel_NoticeLevel2 = 2,
  kWarningLevel_WarningLevel1 = 3,
  kWarningLevel_WarningLevel2 = 4
};
bool WarningLevel_IsValid(int value);
const WarningLevel WarningLevel_MIN = kWarningLevel_None;
const WarningLevel WarningLevel_MAX = kWarningLevel_WarningLevel2;
const int WarningLevel_ARRAYSIZE = WarningLevel_MAX + 1;

const ::google::protobuf::EnumDescriptor* WarningLevel_descriptor();
inline const ::std::string& WarningLevel_Name(WarningLevel value) {
  return ::google::protobuf::internal::NameOfEnum(
    WarningLevel_descriptor(), value);
}
inline bool WarningLevel_Parse(
    const ::std::string& name, WarningLevel* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WarningLevel>(
    WarningLevel_descriptor(), name, value);
}
enum WarningType {
  kWarningLevel_Hmw = 0,
  kWarningLevel_Fcw = 1,
  kWarningLevel_Pcw = 2,
  kWarningLevel_Ldw = 3
};
bool WarningType_IsValid(int value);
const WarningType WarningType_MIN = kWarningLevel_Hmw;
const WarningType WarningType_MAX = kWarningLevel_Ldw;
const int WarningType_ARRAYSIZE = WarningType_MAX + 1;

const ::google::protobuf::EnumDescriptor* WarningType_descriptor();
inline const ::std::string& WarningType_Name(WarningType value) {
  return ::google::protobuf::internal::NameOfEnum(
    WarningType_descriptor(), value);
}
inline bool WarningType_Parse(
    const ::std::string& name, WarningType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<WarningType>(
    WarningType_descriptor(), name, value);
}
// ===================================================================

class GroundPoint : public ::google::protobuf::Message {
 public:
  GroundPoint();
  virtual ~GroundPoint();

  GroundPoint(const GroundPoint& from);

  inline GroundPoint& operator=(const GroundPoint& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GroundPoint& default_instance();

  void Swap(GroundPoint* other);

  // implements Message ----------------------------------------------

  GroundPoint* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GroundPoint& from);
  void MergeFrom(const GroundPoint& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // required float z = 2;
  inline bool has_z() const;
  inline void clear_z();
  static const int kZFieldNumber = 2;
  inline float z() const;
  inline void set_z(float value);

  // @@protoc_insertion_point(class_scope:AdasOutputProtocol.GroundPoint)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_z();
  inline void clear_has_z();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float x_;
  float z_;
  friend void  protobuf_AddDesc_adas_5foutput_2eproto();
  friend void protobuf_AssignDesc_adas_5foutput_2eproto();
  friend void protobuf_ShutdownFile_adas_5foutput_2eproto();

  void InitAsDefaultInstance();
  static GroundPoint* default_instance_;
};
// -------------------------------------------------------------------

class Rect : public ::google::protobuf::Message {
 public:
  Rect();
  virtual ~Rect();

  Rect(const Rect& from);

  inline Rect& operator=(const Rect& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Rect& default_instance();

  void Swap(Rect* other);

  // implements Message ----------------------------------------------

  Rect* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Rect& from);
  void MergeFrom(const Rect& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required float left = 1;
  inline bool has_left() const;
  inline void clear_left();
  static const int kLeftFieldNumber = 1;
  inline float left() const;
  inline void set_left(float value);

  // required float top = 2;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 2;
  inline float top() const;
  inline void set_top(float value);

  // required float right = 3;
  inline bool has_right() const;
  inline void clear_right();
  static const int kRightFieldNumber = 3;
  inline float right() const;
  inline void set_right(float value);

  // required float bottom = 4;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 4;
  inline float bottom() const;
  inline void set_bottom(float value);

  // @@protoc_insertion_point(class_scope:AdasOutputProtocol.Rect)
 private:
  inline void set_has_left();
  inline void clear_has_left();
  inline void set_has_top();
  inline void clear_has_top();
  inline void set_has_right();
  inline void clear_has_right();
  inline void set_has_bottom();
  inline void clear_has_bottom();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  float left_;
  float top_;
  float right_;
  float bottom_;
  friend void  protobuf_AddDesc_adas_5foutput_2eproto();
  friend void protobuf_AssignDesc_adas_5foutput_2eproto();
  friend void protobuf_ShutdownFile_adas_5foutput_2eproto();

  void InitAsDefaultInstance();
  static Rect* default_instance_;
};
// -------------------------------------------------------------------

class CameraInfo : public ::google::protobuf::Message {
 public:
  CameraInfo();
  virtual ~CameraInfo();

  CameraInfo(const CameraInfo& from);

  inline CameraInfo& operator=(const CameraInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CameraInfo& default_instance();

  void Swap(CameraInfo* other);

  // implements Message ----------------------------------------------

  CameraInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CameraInfo& from);
  void MergeFrom(const CameraInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated float M_ = 1;
  inline int m__size() const;
  inline void clear_m_();
  static const int kMFieldNumber = 1;
  inline float m_(int index) const;
  inline void set_m_(int index, float value);
  inline void add_m_(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      m_() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_m_();

  // repeated float MInv_ = 2;
  inline int minv__size() const;
  inline void clear_minv_();
  static const int kMInvFieldNumber = 2;
  inline float minv_(int index) const;
  inline void set_minv_(int index, float value);
  inline void add_minv_(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      minv_() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_minv_();

  // @@protoc_insertion_point(class_scope:AdasOutputProtocol.CameraInfo)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< float > m__;
  ::google::protobuf::RepeatedField< float > minv__;
  friend void  protobuf_AddDesc_adas_5foutput_2eproto();
  friend void protobuf_AssignDesc_adas_5foutput_2eproto();
  friend void protobuf_ShutdownFile_adas_5foutput_2eproto();

  void InitAsDefaultInstance();
  static CameraInfo* default_instance_;
};
// -------------------------------------------------------------------

class ImageFrame : public ::google::protobuf::Message {
 public:
  ImageFrame();
  virtual ~ImageFrame();

  ImageFrame(const ImageFrame& from);

  inline ImageFrame& operator=(const ImageFrame& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ImageFrame& default_instance();

  void Swap(ImageFrame* other);

  // implements Message ----------------------------------------------

  ImageFrame* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ImageFrame& from);
  void MergeFrom(const ImageFrame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 width = 1;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 1;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);

  // required int32 height = 2;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 2;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);

  // required int64 time_stamp = 3;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 3;
  inline ::google::protobuf::int64 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::int64 value);

  // optional int32 channel = 4;
  inline bool has_channel() const;
  inline void clear_channel();
  static const int kChannelFieldNumber = 4;
  inline ::google::protobuf::int32 channel() const;
  inline void set_channel(::google::protobuf::int32 value);

  // optional int32 send_mode = 5;
  inline bool has_send_mode() const;
  inline void clear_send_mode();
  static const int kSendModeFieldNumber = 5;
  inline ::google::protobuf::int32 send_mode() const;
  inline void set_send_mode(::google::protobuf::int32 value);

  // optional int32 format = 6;
  inline bool has_format() const;
  inline void clear_format();
  static const int kFormatFieldNumber = 6;
  inline ::google::protobuf::int32 format() const;
  inline void set_format(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AdasOutputProtocol.ImageFrame)
 private:
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_channel();
  inline void clear_has_channel();
  inline void set_has_send_mode();
  inline void clear_has_send_mode();
  inline void set_has_format();
  inline void clear_has_format();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 width_;
  ::google::protobuf::int32 height_;
  ::google::protobuf::int64 time_stamp_;
  ::google::protobuf::int32 channel_;
  ::google::protobuf::int32 send_mode_;
  ::google::protobuf::int32 format_;
  friend void  protobuf_AddDesc_adas_5foutput_2eproto();
  friend void protobuf_AssignDesc_adas_5foutput_2eproto();
  friend void protobuf_ShutdownFile_adas_5foutput_2eproto();

  void InitAsDefaultInstance();
  static ImageFrame* default_instance_;
};
// -------------------------------------------------------------------

class GPS : public ::google::protobuf::Message {
 public:
  GPS();
  virtual ~GPS();

  GPS(const GPS& from);

  inline GPS& operator=(const GPS& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GPS& default_instance();

  void Swap(GPS* other);

  // implements Message ----------------------------------------------

  GPS* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GPS& from);
  void MergeFrom(const GPS& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 time_stamp = 1;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 1;
  inline ::google::protobuf::int64 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::int64 value);

  // required double longitude = 2;
  inline bool has_longitude() const;
  inline void clear_longitude();
  static const int kLongitudeFieldNumber = 2;
  inline double longitude() const;
  inline void set_longitude(double value);

  // required double latitude = 3;
  inline bool has_latitude() const;
  inline void clear_latitude();
  static const int kLatitudeFieldNumber = 3;
  inline double latitude() const;
  inline void set_latitude(double value);

  // optional float altitude = 4;
  inline bool has_altitude() const;
  inline void clear_altitude();
  static const int kAltitudeFieldNumber = 4;
  inline float altitude() const;
  inline void set_altitude(float value);

  // optional int64 gps_time = 5;
  inline bool has_gps_time() const;
  inline void clear_gps_time();
  static const int kGpsTimeFieldNumber = 5;
  inline ::google::protobuf::int64 gps_time() const;
  inline void set_gps_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:AdasOutputProtocol.GPS)
 private:
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_longitude();
  inline void clear_has_longitude();
  inline void set_has_latitude();
  inline void clear_has_latitude();
  inline void set_has_altitude();
  inline void clear_has_altitude();
  inline void set_has_gps_time();
  inline void clear_has_gps_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 time_stamp_;
  double longitude_;
  double latitude_;
  ::google::protobuf::int64 gps_time_;
  float altitude_;
  friend void  protobuf_AddDesc_adas_5foutput_2eproto();
  friend void protobuf_AssignDesc_adas_5foutput_2eproto();
  friend void protobuf_ShutdownFile_adas_5foutput_2eproto();

  void InitAsDefaultInstance();
  static GPS* default_instance_;
};
// -------------------------------------------------------------------

class Motion : public ::google::protobuf::Message {
 public:
  Motion();
  virtual ~Motion();

  Motion(const Motion& from);

  inline Motion& operator=(const Motion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Motion& default_instance();

  void Swap(Motion* other);

  // implements Message ----------------------------------------------

  Motion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Motion& from);
  void MergeFrom(const Motion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int64 time_stamp = 1;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 1;
  inline ::google::protobuf::int64 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::int64 value);

  // optional float velocity = 2;
  inline bool has_velocity() const;
  inline void clear_velocity();
  static const int kVelocityFieldNumber = 2;
  inline float velocity() const;
  inline void set_velocity(float value);

  // optional float yaw_rate = 3;
  inline bool has_yaw_rate() const;
  inline void clear_yaw_rate();
  static const int kYawRateFieldNumber = 3;
  inline float yaw_rate() const;
  inline void set_yaw_rate(float value);

  // optional float acc = 4;
  inline bool has_acc() const;
  inline void clear_acc();
  static const int kAccFieldNumber = 4;
  inline float acc() const;
  inline void set_acc(float value);

  // @@protoc_insertion_point(class_scope:AdasOutputProtocol.Motion)
 private:
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_velocity();
  inline void clear_has_velocity();
  inline void set_has_yaw_rate();
  inline void clear_has_yaw_rate();
  inline void set_has_acc();
  inline void clear_has_acc();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int64 time_stamp_;
  float velocity_;
  float yaw_rate_;
  float acc_;
  friend void  protobuf_AddDesc_adas_5foutput_2eproto();
  friend void protobuf_AssignDesc_adas_5foutput_2eproto();
  friend void protobuf_ShutdownFile_adas_5foutput_2eproto();

  void InitAsDefaultInstance();
  static Motion* default_instance_;
};
// -------------------------------------------------------------------

class Line : public ::google::protobuf::Message {
 public:
  Line();
  virtual ~Line();

  Line(const Line& from);

  inline Line& operator=(const Line& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Line& default_instance();

  void Swap(Line* other);

  // implements Message ----------------------------------------------

  Line* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Line& from);
  void MergeFrom(const Line& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int64 time_stamp = 3;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 3;
  inline ::google::protobuf::int64 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::int64 value);

  // repeated float coeffs = 4;
  inline int coeffs_size() const;
  inline void clear_coeffs();
  static const int kCoeffsFieldNumber = 4;
  inline float coeffs(int index) const;
  inline void set_coeffs(int index, float value);
  inline void add_coeffs(float value);
  inline const ::google::protobuf::RepeatedField< float >&
      coeffs() const;
  inline ::google::protobuf::RepeatedField< float >*
      mutable_coeffs();

  // repeated .AdasOutputProtocol.GroundPoint end_points = 5;
  inline int end_points_size() const;
  inline void clear_end_points();
  static const int kEndPointsFieldNumber = 5;
  inline const ::AdasOutputProtocol::GroundPoint& end_points(int index) const;
  inline ::AdasOutputProtocol::GroundPoint* mutable_end_points(int index);
  inline ::AdasOutputProtocol::GroundPoint* add_end_points();
  inline const ::google::protobuf::RepeatedPtrField< ::AdasOutputProtocol::GroundPoint >&
      end_points() const;
  inline ::google::protobuf::RepeatedPtrField< ::AdasOutputProtocol::GroundPoint >*
      mutable_end_points();

  // optional float line_cross_distance = 6;
  inline bool has_line_cross_distance() const;
  inline void clear_line_cross_distance();
  static const int kLineCrossDistanceFieldNumber = 6;
  inline float line_cross_distance() const;
  inline void set_line_cross_distance(float value);

  // optional float ttlc = 7;
  inline bool has_ttlc() const;
  inline void clear_ttlc();
  static const int kTtlcFieldNumber = 7;
  inline float ttlc() const;
  inline void set_ttlc(float value);

  // optional float depature_v = 8;
  inline bool has_depature_v() const;
  inline void clear_depature_v();
  static const int kDepatureVFieldNumber = 8;
  inline float depature_v() const;
  inline void set_depature_v(float value);

  // optional int64 tracking_time = 9;
  inline bool has_tracking_time() const;
  inline void clear_tracking_time();
  static const int kTrackingTimeFieldNumber = 9;
  inline ::google::protobuf::int64 tracking_time() const;
  inline void set_tracking_time(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:AdasOutputProtocol.Line)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_line_cross_distance();
  inline void clear_has_line_cross_distance();
  inline void set_has_ttlc();
  inline void clear_has_ttlc();
  inline void set_has_depature_v();
  inline void clear_has_depature_v();
  inline void set_has_tracking_time();
  inline void clear_has_tracking_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int64 time_stamp_;
  ::google::protobuf::RepeatedField< float > coeffs_;
  ::google::protobuf::RepeatedPtrField< ::AdasOutputProtocol::GroundPoint > end_points_;
  float line_cross_distance_;
  float ttlc_;
  ::google::protobuf::int64 tracking_time_;
  float depature_v_;
  friend void  protobuf_AddDesc_adas_5foutput_2eproto();
  friend void protobuf_AssignDesc_adas_5foutput_2eproto();
  friend void protobuf_ShutdownFile_adas_5foutput_2eproto();

  void InitAsDefaultInstance();
  static Line* default_instance_;
};
// -------------------------------------------------------------------

class Object : public ::google::protobuf::Message {
 public:
  Object();
  virtual ~Object();

  Object(const Object& from);

  inline Object& operator=(const Object& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Object& default_instance();

  void Swap(Object* other);

  // implements Message ----------------------------------------------

  Object* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Object& from);
  void MergeFrom(const Object& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 type = 2;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 2;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int64 time_stamp = 3;
  inline bool has_time_stamp() const;
  inline void clear_time_stamp();
  static const int kTimeStampFieldNumber = 3;
  inline ::google::protobuf::int64 time_stamp() const;
  inline void set_time_stamp(::google::protobuf::int64 value);

  // optional .AdasOutputProtocol.GroundPoint relative_location = 4;
  inline bool has_relative_location() const;
  inline void clear_relative_location();
  static const int kRelativeLocationFieldNumber = 4;
  inline const ::AdasOutputProtocol::GroundPoint& relative_location() const;
  inline ::AdasOutputProtocol::GroundPoint* mutable_relative_location();
  inline ::AdasOutputProtocol::GroundPoint* release_relative_location();
  inline void set_allocated_relative_location(::AdasOutputProtocol::GroundPoint* relative_location);

  // optional .AdasOutputProtocol.GroundPoint relative_velocity = 5;
  inline bool has_relative_velocity() const;
  inline void clear_relative_velocity();
  static const int kRelativeVelocityFieldNumber = 5;
  inline const ::AdasOutputProtocol::GroundPoint& relative_velocity() const;
  inline ::AdasOutputProtocol::GroundPoint* mutable_relative_velocity();
  inline ::AdasOutputProtocol::GroundPoint* release_relative_velocity();
  inline void set_allocated_relative_velocity(::AdasOutputProtocol::GroundPoint* relative_velocity);

  // optional float ttc = 6;
  inline bool has_ttc() const;
  inline void clear_ttc();
  static const int kTtcFieldNumber = 6;
  inline float ttc() const;
  inline void set_ttc(float value);

  // optional .AdasOutputProtocol.Rect rect = 7;
  inline bool has_rect() const;
  inline void clear_rect();
  static const int kRectFieldNumber = 7;
  inline const ::AdasOutputProtocol::Rect& rect() const;
  inline ::AdasOutputProtocol::Rect* mutable_rect();
  inline ::AdasOutputProtocol::Rect* release_rect();
  inline void set_allocated_rect(::AdasOutputProtocol::Rect* rect);

  // optional int64 tracking_time = 8;
  inline bool has_tracking_time() const;
  inline void clear_tracking_time();
  static const int kTrackingTimeFieldNumber = 8;
  inline ::google::protobuf::int64 tracking_time() const;
  inline void set_tracking_time(::google::protobuf::int64 value);

  // optional bool is_key_object = 9;
  inline bool has_is_key_object() const;
  inline void clear_is_key_object();
  static const int kIsKeyObjectFieldNumber = 9;
  inline bool is_key_object() const;
  inline void set_is_key_object(bool value);

  // @@protoc_insertion_point(class_scope:AdasOutputProtocol.Object)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_time_stamp();
  inline void clear_has_time_stamp();
  inline void set_has_relative_location();
  inline void clear_has_relative_location();
  inline void set_has_relative_velocity();
  inline void clear_has_relative_velocity();
  inline void set_has_ttc();
  inline void clear_has_ttc();
  inline void set_has_rect();
  inline void clear_has_rect();
  inline void set_has_tracking_time();
  inline void clear_has_tracking_time();
  inline void set_has_is_key_object();
  inline void clear_has_is_key_object();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 type_;
  ::google::protobuf::int64 time_stamp_;
  ::AdasOutputProtocol::GroundPoint* relative_location_;
  ::AdasOutputProtocol::GroundPoint* relative_velocity_;
  ::AdasOutputProtocol::Rect* rect_;
  float ttc_;
  bool is_key_object_;
  ::google::protobuf::int64 tracking_time_;
  friend void  protobuf_AddDesc_adas_5foutput_2eproto();
  friend void protobuf_AssignDesc_adas_5foutput_2eproto();
  friend void protobuf_ShutdownFile_adas_5foutput_2eproto();

  void InitAsDefaultInstance();
  static Object* default_instance_;
};
// -------------------------------------------------------------------

class HMW : public ::google::protobuf::Message {
 public:
  HMW();
  virtual ~HMW();

  HMW(const HMW& from);

  inline HMW& operator=(const HMW& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const HMW& default_instance();

  void Swap(HMW* other);

  // implements Message ----------------------------------------------

  HMW* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const HMW& from);
  void MergeFrom(const HMW& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef HMW_HmwLevel HmwLevel;
  static const HmwLevel kHmwLevel_None = HMW_HmwLevel_kHmwLevel_None;
  static const HmwLevel kHmwLevel_NoticeLevel1 = HMW_HmwLevel_kHmwLevel_NoticeLevel1;
  static const HmwLevel kHmwLevel_NoticeLevel2 = HMW_HmwLevel_kHmwLevel_NoticeLevel2;
  static const HmwLevel kHmwLevel_WarningLevel1 = HMW_HmwLevel_kHmwLevel_WarningLevel1;
  static const HmwLevel kHmwLevel_WarningLevel2 = HMW_HmwLevel_kHmwLevel_WarningLevel2;
  static inline bool HmwLevel_IsValid(int value) {
    return HMW_HmwLevel_IsValid(value);
  }
  static const HmwLevel HmwLevel_MIN =
    HMW_HmwLevel_HmwLevel_MIN;
  static const HmwLevel HmwLevel_MAX =
    HMW_HmwLevel_HmwLevel_MAX;
  static const int HmwLevel_ARRAYSIZE =
    HMW_HmwLevel_HmwLevel_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  HmwLevel_descriptor() {
    return HMW_HmwLevel_descriptor();
  }
  static inline const ::std::string& HmwLevel_Name(HmwLevel value) {
    return HMW_HmwLevel_Name(value);
  }
  static inline bool HmwLevel_Parse(const ::std::string& name,
      HmwLevel* value) {
    return HMW_HmwLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 function_status = 1;
  inline bool has_function_status() const;
  inline void clear_function_status();
  static const int kFunctionStatusFieldNumber = 1;
  inline ::google::protobuf::int32 function_status() const;
  inline void set_function_status(::google::protobuf::int32 value);

  // optional int32 warning_level = 2;
  inline bool has_warning_level() const;
  inline void clear_warning_level();
  static const int kWarningLevelFieldNumber = 2;
  inline ::google::protobuf::int32 warning_level() const;
  inline void set_warning_level(::google::protobuf::int32 value);

  // optional float time_to_conllision = 3;
  inline bool has_time_to_conllision() const;
  inline void clear_time_to_conllision();
  static const int kTimeToConllisionFieldNumber = 3;
  inline float time_to_conllision() const;
  inline void set_time_to_conllision(float value);

  // optional int32 object_type = 4;
  inline bool has_object_type() const;
  inline void clear_object_type();
  static const int kObjectTypeFieldNumber = 4;
  inline ::google::protobuf::int32 object_type() const;
  inline void set_object_type(::google::protobuf::int32 value);

  // optional int32 veh_id = 5;
  inline bool has_veh_id() const;
  inline void clear_veh_id();
  static const int kVehIdFieldNumber = 5;
  inline ::google::protobuf::int32 veh_id() const;
  inline void set_veh_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AdasOutputProtocol.HMW)
 private:
  inline void set_has_function_status();
  inline void clear_has_function_status();
  inline void set_has_warning_level();
  inline void clear_has_warning_level();
  inline void set_has_time_to_conllision();
  inline void clear_has_time_to_conllision();
  inline void set_has_object_type();
  inline void clear_has_object_type();
  inline void set_has_veh_id();
  inline void clear_has_veh_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 function_status_;
  ::google::protobuf::int32 warning_level_;
  float time_to_conllision_;
  ::google::protobuf::int32 object_type_;
  ::google::protobuf::int32 veh_id_;
  friend void  protobuf_AddDesc_adas_5foutput_2eproto();
  friend void protobuf_AssignDesc_adas_5foutput_2eproto();
  friend void protobuf_ShutdownFile_adas_5foutput_2eproto();

  void InitAsDefaultInstance();
  static HMW* default_instance_;
};
// -------------------------------------------------------------------

class FCW : public ::google::protobuf::Message {
 public:
  FCW();
  virtual ~FCW();

  FCW(const FCW& from);

  inline FCW& operator=(const FCW& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FCW& default_instance();

  void Swap(FCW* other);

  // implements Message ----------------------------------------------

  FCW* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FCW& from);
  void MergeFrom(const FCW& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef FCW_FcwLevel FcwLevel;
  static const FcwLevel kFcwLevel_None = FCW_FcwLevel_kFcwLevel_None;
  static const FcwLevel kFcwLevel_Warning = FCW_FcwLevel_kFcwLevel_Warning;
  static inline bool FcwLevel_IsValid(int value) {
    return FCW_FcwLevel_IsValid(value);
  }
  static const FcwLevel FcwLevel_MIN =
    FCW_FcwLevel_FcwLevel_MIN;
  static const FcwLevel FcwLevel_MAX =
    FCW_FcwLevel_FcwLevel_MAX;
  static const int FcwLevel_ARRAYSIZE =
    FCW_FcwLevel_FcwLevel_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FcwLevel_descriptor() {
    return FCW_FcwLevel_descriptor();
  }
  static inline const ::std::string& FcwLevel_Name(FcwLevel value) {
    return FCW_FcwLevel_Name(value);
  }
  static inline bool FcwLevel_Parse(const ::std::string& name,
      FcwLevel* value) {
    return FCW_FcwLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 function_status = 1;
  inline bool has_function_status() const;
  inline void clear_function_status();
  static const int kFunctionStatusFieldNumber = 1;
  inline ::google::protobuf::int32 function_status() const;
  inline void set_function_status(::google::protobuf::int32 value);

  // optional int32 warning_level = 2;
  inline bool has_warning_level() const;
  inline void clear_warning_level();
  static const int kWarningLevelFieldNumber = 2;
  inline ::google::protobuf::int32 warning_level() const;
  inline void set_warning_level(::google::protobuf::int32 value);

  // optional float time_to_conllision = 3;
  inline bool has_time_to_conllision() const;
  inline void clear_time_to_conllision();
  static const int kTimeToConllisionFieldNumber = 3;
  inline float time_to_conllision() const;
  inline void set_time_to_conllision(float value);

  // optional int32 object_type = 4;
  inline bool has_object_type() const;
  inline void clear_object_type();
  static const int kObjectTypeFieldNumber = 4;
  inline ::google::protobuf::int32 object_type() const;
  inline void set_object_type(::google::protobuf::int32 value);

  // optional int32 veh_id = 5;
  inline bool has_veh_id() const;
  inline void clear_veh_id();
  static const int kVehIdFieldNumber = 5;
  inline ::google::protobuf::int32 veh_id() const;
  inline void set_veh_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AdasOutputProtocol.FCW)
 private:
  inline void set_has_function_status();
  inline void clear_has_function_status();
  inline void set_has_warning_level();
  inline void clear_has_warning_level();
  inline void set_has_time_to_conllision();
  inline void clear_has_time_to_conllision();
  inline void set_has_object_type();
  inline void clear_has_object_type();
  inline void set_has_veh_id();
  inline void clear_has_veh_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 function_status_;
  ::google::protobuf::int32 warning_level_;
  float time_to_conllision_;
  ::google::protobuf::int32 object_type_;
  ::google::protobuf::int32 veh_id_;
  friend void  protobuf_AddDesc_adas_5foutput_2eproto();
  friend void protobuf_AssignDesc_adas_5foutput_2eproto();
  friend void protobuf_ShutdownFile_adas_5foutput_2eproto();

  void InitAsDefaultInstance();
  static FCW* default_instance_;
};
// -------------------------------------------------------------------

class PCW : public ::google::protobuf::Message {
 public:
  PCW();
  virtual ~PCW();

  PCW(const PCW& from);

  inline PCW& operator=(const PCW& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PCW& default_instance();

  void Swap(PCW* other);

  // implements Message ----------------------------------------------

  PCW* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PCW& from);
  void MergeFrom(const PCW& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PCW_PcwLevel PcwLevel;
  static const PcwLevel kPcwLevel_None = PCW_PcwLevel_kPcwLevel_None;
  static const PcwLevel kPcwLevel_Warning = PCW_PcwLevel_kPcwLevel_Warning;
  static inline bool PcwLevel_IsValid(int value) {
    return PCW_PcwLevel_IsValid(value);
  }
  static const PcwLevel PcwLevel_MIN =
    PCW_PcwLevel_PcwLevel_MIN;
  static const PcwLevel PcwLevel_MAX =
    PCW_PcwLevel_PcwLevel_MAX;
  static const int PcwLevel_ARRAYSIZE =
    PCW_PcwLevel_PcwLevel_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PcwLevel_descriptor() {
    return PCW_PcwLevel_descriptor();
  }
  static inline const ::std::string& PcwLevel_Name(PcwLevel value) {
    return PCW_PcwLevel_Name(value);
  }
  static inline bool PcwLevel_Parse(const ::std::string& name,
      PcwLevel* value) {
    return PCW_PcwLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 function_status = 1;
  inline bool has_function_status() const;
  inline void clear_function_status();
  static const int kFunctionStatusFieldNumber = 1;
  inline ::google::protobuf::int32 function_status() const;
  inline void set_function_status(::google::protobuf::int32 value);

  // optional int32 warning_level = 2;
  inline bool has_warning_level() const;
  inline void clear_warning_level();
  static const int kWarningLevelFieldNumber = 2;
  inline ::google::protobuf::int32 warning_level() const;
  inline void set_warning_level(::google::protobuf::int32 value);

  // optional float time_to_conllision = 3;
  inline bool has_time_to_conllision() const;
  inline void clear_time_to_conllision();
  static const int kTimeToConllisionFieldNumber = 3;
  inline float time_to_conllision() const;
  inline void set_time_to_conllision(float value);

  // optional int32 object_type = 4;
  inline bool has_object_type() const;
  inline void clear_object_type();
  static const int kObjectTypeFieldNumber = 4;
  inline ::google::protobuf::int32 object_type() const;
  inline void set_object_type(::google::protobuf::int32 value);

  // optional int32 ped_id = 5;
  inline bool has_ped_id() const;
  inline void clear_ped_id();
  static const int kPedIdFieldNumber = 5;
  inline ::google::protobuf::int32 ped_id() const;
  inline void set_ped_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AdasOutputProtocol.PCW)
 private:
  inline void set_has_function_status();
  inline void clear_has_function_status();
  inline void set_has_warning_level();
  inline void clear_has_warning_level();
  inline void set_has_time_to_conllision();
  inline void clear_has_time_to_conllision();
  inline void set_has_object_type();
  inline void clear_has_object_type();
  inline void set_has_ped_id();
  inline void clear_has_ped_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 function_status_;
  ::google::protobuf::int32 warning_level_;
  float time_to_conllision_;
  ::google::protobuf::int32 object_type_;
  ::google::protobuf::int32 ped_id_;
  friend void  protobuf_AddDesc_adas_5foutput_2eproto();
  friend void protobuf_AssignDesc_adas_5foutput_2eproto();
  friend void protobuf_ShutdownFile_adas_5foutput_2eproto();

  void InitAsDefaultInstance();
  static PCW* default_instance_;
};
// -------------------------------------------------------------------

class LDW : public ::google::protobuf::Message {
 public:
  LDW();
  virtual ~LDW();

  LDW(const LDW& from);

  inline LDW& operator=(const LDW& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LDW& default_instance();

  void Swap(LDW* other);

  // implements Message ----------------------------------------------

  LDW* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LDW& from);
  void MergeFrom(const LDW& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LDW_LdwLevel LdwLevel;
  static const LdwLevel kLdwLevel_None = LDW_LdwLevel_kLdwLevel_None;
  static const LdwLevel kLdwLevel_WarningLeftSide = LDW_LdwLevel_kLdwLevel_WarningLeftSide;
  static const LdwLevel kLdwLevel_WarningRightSide = LDW_LdwLevel_kLdwLevel_WarningRightSide;
  static inline bool LdwLevel_IsValid(int value) {
    return LDW_LdwLevel_IsValid(value);
  }
  static const LdwLevel LdwLevel_MIN =
    LDW_LdwLevel_LdwLevel_MIN;
  static const LdwLevel LdwLevel_MAX =
    LDW_LdwLevel_LdwLevel_MAX;
  static const int LdwLevel_ARRAYSIZE =
    LDW_LdwLevel_LdwLevel_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LdwLevel_descriptor() {
    return LDW_LdwLevel_descriptor();
  }
  static inline const ::std::string& LdwLevel_Name(LdwLevel value) {
    return LDW_LdwLevel_Name(value);
  }
  static inline bool LdwLevel_Parse(const ::std::string& name,
      LdwLevel* value) {
    return LDW_LdwLevel_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional int32 function_status = 1;
  inline bool has_function_status() const;
  inline void clear_function_status();
  static const int kFunctionStatusFieldNumber = 1;
  inline ::google::protobuf::int32 function_status() const;
  inline void set_function_status(::google::protobuf::int32 value);

  // optional int32 warning_level = 2;
  inline bool has_warning_level() const;
  inline void clear_warning_level();
  static const int kWarningLevelFieldNumber = 2;
  inline ::google::protobuf::int32 warning_level() const;
  inline void set_warning_level(::google::protobuf::int32 value);

  // optional float line_cross_distance = 3;
  inline bool has_line_cross_distance() const;
  inline void clear_line_cross_distance();
  static const int kLineCrossDistanceFieldNumber = 3;
  inline float line_cross_distance() const;
  inline void set_line_cross_distance(float value);

  // optional int32 object_type = 4;
  inline bool has_object_type() const;
  inline void clear_object_type();
  static const int kObjectTypeFieldNumber = 4;
  inline ::google::protobuf::int32 object_type() const;
  inline void set_object_type(::google::protobuf::int32 value);

  // optional int32 line_id = 5;
  inline bool has_line_id() const;
  inline void clear_line_id();
  static const int kLineIdFieldNumber = 5;
  inline ::google::protobuf::int32 line_id() const;
  inline void set_line_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AdasOutputProtocol.LDW)
 private:
  inline void set_has_function_status();
  inline void clear_has_function_status();
  inline void set_has_warning_level();
  inline void clear_has_warning_level();
  inline void set_has_line_cross_distance();
  inline void clear_has_line_cross_distance();
  inline void set_has_object_type();
  inline void clear_has_object_type();
  inline void set_has_line_id();
  inline void clear_has_line_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 function_status_;
  ::google::protobuf::int32 warning_level_;
  float line_cross_distance_;
  ::google::protobuf::int32 object_type_;
  ::google::protobuf::int32 line_id_;
  friend void  protobuf_AddDesc_adas_5foutput_2eproto();
  friend void protobuf_AssignDesc_adas_5foutput_2eproto();
  friend void protobuf_ShutdownFile_adas_5foutput_2eproto();

  void InitAsDefaultInstance();
  static LDW* default_instance_;
};
// -------------------------------------------------------------------

class WarningResult : public ::google::protobuf::Message {
 public:
  WarningResult();
  virtual ~WarningResult();

  WarningResult(const WarningResult& from);

  inline WarningResult& operator=(const WarningResult& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const WarningResult& default_instance();

  void Swap(WarningResult* other);

  // implements Message ----------------------------------------------

  WarningResult* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const WarningResult& from);
  void MergeFrom(const WarningResult& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .AdasOutputProtocol.HMW hmw = 1;
  inline bool has_hmw() const;
  inline void clear_hmw();
  static const int kHmwFieldNumber = 1;
  inline const ::AdasOutputProtocol::HMW& hmw() const;
  inline ::AdasOutputProtocol::HMW* mutable_hmw();
  inline ::AdasOutputProtocol::HMW* release_hmw();
  inline void set_allocated_hmw(::AdasOutputProtocol::HMW* hmw);

  // optional .AdasOutputProtocol.FCW fcw = 2;
  inline bool has_fcw() const;
  inline void clear_fcw();
  static const int kFcwFieldNumber = 2;
  inline const ::AdasOutputProtocol::FCW& fcw() const;
  inline ::AdasOutputProtocol::FCW* mutable_fcw();
  inline ::AdasOutputProtocol::FCW* release_fcw();
  inline void set_allocated_fcw(::AdasOutputProtocol::FCW* fcw);

  // optional .AdasOutputProtocol.LDW ldw = 3;
  inline bool has_ldw() const;
  inline void clear_ldw();
  static const int kLdwFieldNumber = 3;
  inline const ::AdasOutputProtocol::LDW& ldw() const;
  inline ::AdasOutputProtocol::LDW* mutable_ldw();
  inline ::AdasOutputProtocol::LDW* release_ldw();
  inline void set_allocated_ldw(::AdasOutputProtocol::LDW* ldw);

  // optional .AdasOutputProtocol.PCW pcw = 4;
  inline bool has_pcw() const;
  inline void clear_pcw();
  static const int kPcwFieldNumber = 4;
  inline const ::AdasOutputProtocol::PCW& pcw() const;
  inline ::AdasOutputProtocol::PCW* mutable_pcw();
  inline ::AdasOutputProtocol::PCW* release_pcw();
  inline void set_allocated_pcw(::AdasOutputProtocol::PCW* pcw);

  // optional int32 warning_type = 5;
  inline bool has_warning_type() const;
  inline void clear_warning_type();
  static const int kWarningTypeFieldNumber = 5;
  inline ::google::protobuf::int32 warning_type() const;
  inline void set_warning_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:AdasOutputProtocol.WarningResult)
 private:
  inline void set_has_hmw();
  inline void clear_has_hmw();
  inline void set_has_fcw();
  inline void clear_has_fcw();
  inline void set_has_ldw();
  inline void clear_has_ldw();
  inline void set_has_pcw();
  inline void clear_has_pcw();
  inline void set_has_warning_type();
  inline void clear_has_warning_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::AdasOutputProtocol::HMW* hmw_;
  ::AdasOutputProtocol::FCW* fcw_;
  ::AdasOutputProtocol::LDW* ldw_;
  ::AdasOutputProtocol::PCW* pcw_;
  ::google::protobuf::int32 warning_type_;
  friend void  protobuf_AddDesc_adas_5foutput_2eproto();
  friend void protobuf_AssignDesc_adas_5foutput_2eproto();
  friend void protobuf_ShutdownFile_adas_5foutput_2eproto();

  void InitAsDefaultInstance();
  static WarningResult* default_instance_;
};
// -------------------------------------------------------------------

class AdasOutput : public ::google::protobuf::Message {
 public:
  AdasOutput();
  virtual ~AdasOutput();

  AdasOutput(const AdasOutput& from);

  inline AdasOutput& operator=(const AdasOutput& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AdasOutput& default_instance();

  void Swap(AdasOutput* other);

  // implements Message ----------------------------------------------

  AdasOutput* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AdasOutput& from);
  void MergeFrom(const AdasOutput& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::int32 version() const;
  inline void set_version(::google::protobuf::int32 value);

  // required int32 frame_id = 2;
  inline bool has_frame_id() const;
  inline void clear_frame_id();
  static const int kFrameIdFieldNumber = 2;
  inline ::google::protobuf::int32 frame_id() const;
  inline void set_frame_id(::google::protobuf::int32 value);

  // optional .AdasOutputProtocol.CameraInfo camera = 3;
  inline bool has_camera() const;
  inline void clear_camera();
  static const int kCameraFieldNumber = 3;
  inline const ::AdasOutputProtocol::CameraInfo& camera() const;
  inline ::AdasOutputProtocol::CameraInfo* mutable_camera();
  inline ::AdasOutputProtocol::CameraInfo* release_camera();
  inline void set_allocated_camera(::AdasOutputProtocol::CameraInfo* camera);

  // optional .AdasOutputProtocol.ImageFrame image = 4;
  inline bool has_image() const;
  inline void clear_image();
  static const int kImageFieldNumber = 4;
  inline const ::AdasOutputProtocol::ImageFrame& image() const;
  inline ::AdasOutputProtocol::ImageFrame* mutable_image();
  inline ::AdasOutputProtocol::ImageFrame* release_image();
  inline void set_allocated_image(::AdasOutputProtocol::ImageFrame* image);

  // optional .AdasOutputProtocol.GPS gps = 5;
  inline bool has_gps() const;
  inline void clear_gps();
  static const int kGpsFieldNumber = 5;
  inline const ::AdasOutputProtocol::GPS& gps() const;
  inline ::AdasOutputProtocol::GPS* mutable_gps();
  inline ::AdasOutputProtocol::GPS* release_gps();
  inline void set_allocated_gps(::AdasOutputProtocol::GPS* gps);

  // optional .AdasOutputProtocol.Motion motion = 6;
  inline bool has_motion() const;
  inline void clear_motion();
  static const int kMotionFieldNumber = 6;
  inline const ::AdasOutputProtocol::Motion& motion() const;
  inline ::AdasOutputProtocol::Motion* mutable_motion();
  inline ::AdasOutputProtocol::Motion* release_motion();
  inline void set_allocated_motion(::AdasOutputProtocol::Motion* motion);

  // repeated .AdasOutputProtocol.Object vehicles = 7;
  inline int vehicles_size() const;
  inline void clear_vehicles();
  static const int kVehiclesFieldNumber = 7;
  inline const ::AdasOutputProtocol::Object& vehicles(int index) const;
  inline ::AdasOutputProtocol::Object* mutable_vehicles(int index);
  inline ::AdasOutputProtocol::Object* add_vehicles();
  inline const ::google::protobuf::RepeatedPtrField< ::AdasOutputProtocol::Object >&
      vehicles() const;
  inline ::google::protobuf::RepeatedPtrField< ::AdasOutputProtocol::Object >*
      mutable_vehicles();

  // repeated .AdasOutputProtocol.Object pedestrians = 8;
  inline int pedestrians_size() const;
  inline void clear_pedestrians();
  static const int kPedestriansFieldNumber = 8;
  inline const ::AdasOutputProtocol::Object& pedestrians(int index) const;
  inline ::AdasOutputProtocol::Object* mutable_pedestrians(int index);
  inline ::AdasOutputProtocol::Object* add_pedestrians();
  inline const ::google::protobuf::RepeatedPtrField< ::AdasOutputProtocol::Object >&
      pedestrians() const;
  inline ::google::protobuf::RepeatedPtrField< ::AdasOutputProtocol::Object >*
      mutable_pedestrians();

  // repeated .AdasOutputProtocol.Line lines = 9;
  inline int lines_size() const;
  inline void clear_lines();
  static const int kLinesFieldNumber = 9;
  inline const ::AdasOutputProtocol::Line& lines(int index) const;
  inline ::AdasOutputProtocol::Line* mutable_lines(int index);
  inline ::AdasOutputProtocol::Line* add_lines();
  inline const ::google::protobuf::RepeatedPtrField< ::AdasOutputProtocol::Line >&
      lines() const;
  inline ::google::protobuf::RepeatedPtrField< ::AdasOutputProtocol::Line >*
      mutable_lines();

  // optional .AdasOutputProtocol.WarningResult warning_result = 10;
  inline bool has_warning_result() const;
  inline void clear_warning_result();
  static const int kWarningResultFieldNumber = 10;
  inline const ::AdasOutputProtocol::WarningResult& warning_result() const;
  inline ::AdasOutputProtocol::WarningResult* mutable_warning_result();
  inline ::AdasOutputProtocol::WarningResult* release_warning_result();
  inline void set_allocated_warning_result(::AdasOutputProtocol::WarningResult* warning_result);

  // @@protoc_insertion_point(class_scope:AdasOutputProtocol.AdasOutput)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_frame_id();
  inline void clear_has_frame_id();
  inline void set_has_camera();
  inline void clear_has_camera();
  inline void set_has_image();
  inline void clear_has_image();
  inline void set_has_gps();
  inline void clear_has_gps();
  inline void set_has_motion();
  inline void clear_has_motion();
  inline void set_has_warning_result();
  inline void clear_has_warning_result();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::int32 version_;
  ::google::protobuf::int32 frame_id_;
  ::AdasOutputProtocol::CameraInfo* camera_;
  ::AdasOutputProtocol::ImageFrame* image_;
  ::AdasOutputProtocol::GPS* gps_;
  ::AdasOutputProtocol::Motion* motion_;
  ::google::protobuf::RepeatedPtrField< ::AdasOutputProtocol::Object > vehicles_;
  ::google::protobuf::RepeatedPtrField< ::AdasOutputProtocol::Object > pedestrians_;
  ::google::protobuf::RepeatedPtrField< ::AdasOutputProtocol::Line > lines_;
  ::AdasOutputProtocol::WarningResult* warning_result_;
  friend void  protobuf_AddDesc_adas_5foutput_2eproto();
  friend void protobuf_AssignDesc_adas_5foutput_2eproto();
  friend void protobuf_ShutdownFile_adas_5foutput_2eproto();

  void InitAsDefaultInstance();
  static AdasOutput* default_instance_;
};
// ===================================================================


// ===================================================================

// GroundPoint

// required float x = 1;
inline bool GroundPoint::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GroundPoint::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GroundPoint::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GroundPoint::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float GroundPoint::x() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.GroundPoint.x)
  return x_;
}
inline void GroundPoint::set_x(float value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.GroundPoint.x)
}

// required float z = 2;
inline bool GroundPoint::has_z() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GroundPoint::set_has_z() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GroundPoint::clear_has_z() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GroundPoint::clear_z() {
  z_ = 0;
  clear_has_z();
}
inline float GroundPoint::z() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.GroundPoint.z)
  return z_;
}
inline void GroundPoint::set_z(float value) {
  set_has_z();
  z_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.GroundPoint.z)
}

// -------------------------------------------------------------------

// Rect

// required float left = 1;
inline bool Rect::has_left() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Rect::set_has_left() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Rect::clear_has_left() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Rect::clear_left() {
  left_ = 0;
  clear_has_left();
}
inline float Rect::left() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Rect.left)
  return left_;
}
inline void Rect::set_left(float value) {
  set_has_left();
  left_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.Rect.left)
}

// required float top = 2;
inline bool Rect::has_top() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Rect::set_has_top() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Rect::clear_has_top() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Rect::clear_top() {
  top_ = 0;
  clear_has_top();
}
inline float Rect::top() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Rect.top)
  return top_;
}
inline void Rect::set_top(float value) {
  set_has_top();
  top_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.Rect.top)
}

// required float right = 3;
inline bool Rect::has_right() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Rect::set_has_right() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Rect::clear_has_right() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Rect::clear_right() {
  right_ = 0;
  clear_has_right();
}
inline float Rect::right() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Rect.right)
  return right_;
}
inline void Rect::set_right(float value) {
  set_has_right();
  right_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.Rect.right)
}

// required float bottom = 4;
inline bool Rect::has_bottom() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Rect::set_has_bottom() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Rect::clear_has_bottom() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Rect::clear_bottom() {
  bottom_ = 0;
  clear_has_bottom();
}
inline float Rect::bottom() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Rect.bottom)
  return bottom_;
}
inline void Rect::set_bottom(float value) {
  set_has_bottom();
  bottom_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.Rect.bottom)
}

// -------------------------------------------------------------------

// CameraInfo

// repeated float M_ = 1;
inline int CameraInfo::m__size() const {
  return m__.size();
}
inline void CameraInfo::clear_m_() {
  m__.Clear();
}
inline float CameraInfo::m_(int index) const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.CameraInfo.M_)
  return m__.Get(index);
}
inline void CameraInfo::set_m_(int index, float value) {
  m__.Set(index, value);
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.CameraInfo.M_)
}
inline void CameraInfo::add_m_(float value) {
  m__.Add(value);
  // @@protoc_insertion_point(field_add:AdasOutputProtocol.CameraInfo.M_)
}
inline const ::google::protobuf::RepeatedField< float >&
CameraInfo::m_() const {
  // @@protoc_insertion_point(field_list:AdasOutputProtocol.CameraInfo.M_)
  return m__;
}
inline ::google::protobuf::RepeatedField< float >*
CameraInfo::mutable_m_() {
  // @@protoc_insertion_point(field_mutable_list:AdasOutputProtocol.CameraInfo.M_)
  return &m__;
}

// repeated float MInv_ = 2;
inline int CameraInfo::minv__size() const {
  return minv__.size();
}
inline void CameraInfo::clear_minv_() {
  minv__.Clear();
}
inline float CameraInfo::minv_(int index) const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.CameraInfo.MInv_)
  return minv__.Get(index);
}
inline void CameraInfo::set_minv_(int index, float value) {
  minv__.Set(index, value);
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.CameraInfo.MInv_)
}
inline void CameraInfo::add_minv_(float value) {
  minv__.Add(value);
  // @@protoc_insertion_point(field_add:AdasOutputProtocol.CameraInfo.MInv_)
}
inline const ::google::protobuf::RepeatedField< float >&
CameraInfo::minv_() const {
  // @@protoc_insertion_point(field_list:AdasOutputProtocol.CameraInfo.MInv_)
  return minv__;
}
inline ::google::protobuf::RepeatedField< float >*
CameraInfo::mutable_minv_() {
  // @@protoc_insertion_point(field_mutable_list:AdasOutputProtocol.CameraInfo.MInv_)
  return &minv__;
}

// -------------------------------------------------------------------

// ImageFrame

// required int32 width = 1;
inline bool ImageFrame::has_width() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageFrame::set_has_width() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageFrame::clear_has_width() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageFrame::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 ImageFrame::width() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.ImageFrame.width)
  return width_;
}
inline void ImageFrame::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.ImageFrame.width)
}

// required int32 height = 2;
inline bool ImageFrame::has_height() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageFrame::set_has_height() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageFrame::clear_has_height() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageFrame::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 ImageFrame::height() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.ImageFrame.height)
  return height_;
}
inline void ImageFrame::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.ImageFrame.height)
}

// required int64 time_stamp = 3;
inline bool ImageFrame::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageFrame::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageFrame::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageFrame::clear_time_stamp() {
  time_stamp_ = GOOGLE_LONGLONG(0);
  clear_has_time_stamp();
}
inline ::google::protobuf::int64 ImageFrame::time_stamp() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.ImageFrame.time_stamp)
  return time_stamp_;
}
inline void ImageFrame::set_time_stamp(::google::protobuf::int64 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.ImageFrame.time_stamp)
}

// optional int32 channel = 4;
inline bool ImageFrame::has_channel() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageFrame::set_has_channel() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageFrame::clear_has_channel() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageFrame::clear_channel() {
  channel_ = 0;
  clear_has_channel();
}
inline ::google::protobuf::int32 ImageFrame::channel() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.ImageFrame.channel)
  return channel_;
}
inline void ImageFrame::set_channel(::google::protobuf::int32 value) {
  set_has_channel();
  channel_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.ImageFrame.channel)
}

// optional int32 send_mode = 5;
inline bool ImageFrame::has_send_mode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImageFrame::set_has_send_mode() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImageFrame::clear_has_send_mode() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImageFrame::clear_send_mode() {
  send_mode_ = 0;
  clear_has_send_mode();
}
inline ::google::protobuf::int32 ImageFrame::send_mode() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.ImageFrame.send_mode)
  return send_mode_;
}
inline void ImageFrame::set_send_mode(::google::protobuf::int32 value) {
  set_has_send_mode();
  send_mode_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.ImageFrame.send_mode)
}

// optional int32 format = 6;
inline bool ImageFrame::has_format() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ImageFrame::set_has_format() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ImageFrame::clear_has_format() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ImageFrame::clear_format() {
  format_ = 0;
  clear_has_format();
}
inline ::google::protobuf::int32 ImageFrame::format() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.ImageFrame.format)
  return format_;
}
inline void ImageFrame::set_format(::google::protobuf::int32 value) {
  set_has_format();
  format_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.ImageFrame.format)
}

// -------------------------------------------------------------------

// GPS

// required int64 time_stamp = 1;
inline bool GPS::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GPS::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GPS::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GPS::clear_time_stamp() {
  time_stamp_ = GOOGLE_LONGLONG(0);
  clear_has_time_stamp();
}
inline ::google::protobuf::int64 GPS::time_stamp() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.GPS.time_stamp)
  return time_stamp_;
}
inline void GPS::set_time_stamp(::google::protobuf::int64 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.GPS.time_stamp)
}

// required double longitude = 2;
inline bool GPS::has_longitude() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GPS::set_has_longitude() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GPS::clear_has_longitude() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GPS::clear_longitude() {
  longitude_ = 0;
  clear_has_longitude();
}
inline double GPS::longitude() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.GPS.longitude)
  return longitude_;
}
inline void GPS::set_longitude(double value) {
  set_has_longitude();
  longitude_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.GPS.longitude)
}

// required double latitude = 3;
inline bool GPS::has_latitude() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GPS::set_has_latitude() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GPS::clear_has_latitude() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GPS::clear_latitude() {
  latitude_ = 0;
  clear_has_latitude();
}
inline double GPS::latitude() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.GPS.latitude)
  return latitude_;
}
inline void GPS::set_latitude(double value) {
  set_has_latitude();
  latitude_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.GPS.latitude)
}

// optional float altitude = 4;
inline bool GPS::has_altitude() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GPS::set_has_altitude() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GPS::clear_has_altitude() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GPS::clear_altitude() {
  altitude_ = 0;
  clear_has_altitude();
}
inline float GPS::altitude() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.GPS.altitude)
  return altitude_;
}
inline void GPS::set_altitude(float value) {
  set_has_altitude();
  altitude_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.GPS.altitude)
}

// optional int64 gps_time = 5;
inline bool GPS::has_gps_time() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GPS::set_has_gps_time() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GPS::clear_has_gps_time() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GPS::clear_gps_time() {
  gps_time_ = GOOGLE_LONGLONG(0);
  clear_has_gps_time();
}
inline ::google::protobuf::int64 GPS::gps_time() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.GPS.gps_time)
  return gps_time_;
}
inline void GPS::set_gps_time(::google::protobuf::int64 value) {
  set_has_gps_time();
  gps_time_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.GPS.gps_time)
}

// -------------------------------------------------------------------

// Motion

// required int64 time_stamp = 1;
inline bool Motion::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Motion::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Motion::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Motion::clear_time_stamp() {
  time_stamp_ = GOOGLE_LONGLONG(0);
  clear_has_time_stamp();
}
inline ::google::protobuf::int64 Motion::time_stamp() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Motion.time_stamp)
  return time_stamp_;
}
inline void Motion::set_time_stamp(::google::protobuf::int64 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.Motion.time_stamp)
}

// optional float velocity = 2;
inline bool Motion::has_velocity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Motion::set_has_velocity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Motion::clear_has_velocity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Motion::clear_velocity() {
  velocity_ = 0;
  clear_has_velocity();
}
inline float Motion::velocity() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Motion.velocity)
  return velocity_;
}
inline void Motion::set_velocity(float value) {
  set_has_velocity();
  velocity_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.Motion.velocity)
}

// optional float yaw_rate = 3;
inline bool Motion::has_yaw_rate() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Motion::set_has_yaw_rate() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Motion::clear_has_yaw_rate() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Motion::clear_yaw_rate() {
  yaw_rate_ = 0;
  clear_has_yaw_rate();
}
inline float Motion::yaw_rate() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Motion.yaw_rate)
  return yaw_rate_;
}
inline void Motion::set_yaw_rate(float value) {
  set_has_yaw_rate();
  yaw_rate_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.Motion.yaw_rate)
}

// optional float acc = 4;
inline bool Motion::has_acc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Motion::set_has_acc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Motion::clear_has_acc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Motion::clear_acc() {
  acc_ = 0;
  clear_has_acc();
}
inline float Motion::acc() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Motion.acc)
  return acc_;
}
inline void Motion::set_acc(float value) {
  set_has_acc();
  acc_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.Motion.acc)
}

// -------------------------------------------------------------------

// Line

// required int32 id = 1;
inline bool Line::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Line::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Line::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Line::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Line::id() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Line.id)
  return id_;
}
inline void Line::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.Line.id)
}

// optional int32 type = 2;
inline bool Line::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Line::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Line::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Line::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Line::type() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Line.type)
  return type_;
}
inline void Line::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.Line.type)
}

// optional int64 time_stamp = 3;
inline bool Line::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Line::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Line::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Line::clear_time_stamp() {
  time_stamp_ = GOOGLE_LONGLONG(0);
  clear_has_time_stamp();
}
inline ::google::protobuf::int64 Line::time_stamp() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Line.time_stamp)
  return time_stamp_;
}
inline void Line::set_time_stamp(::google::protobuf::int64 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.Line.time_stamp)
}

// repeated float coeffs = 4;
inline int Line::coeffs_size() const {
  return coeffs_.size();
}
inline void Line::clear_coeffs() {
  coeffs_.Clear();
}
inline float Line::coeffs(int index) const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Line.coeffs)
  return coeffs_.Get(index);
}
inline void Line::set_coeffs(int index, float value) {
  coeffs_.Set(index, value);
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.Line.coeffs)
}
inline void Line::add_coeffs(float value) {
  coeffs_.Add(value);
  // @@protoc_insertion_point(field_add:AdasOutputProtocol.Line.coeffs)
}
inline const ::google::protobuf::RepeatedField< float >&
Line::coeffs() const {
  // @@protoc_insertion_point(field_list:AdasOutputProtocol.Line.coeffs)
  return coeffs_;
}
inline ::google::protobuf::RepeatedField< float >*
Line::mutable_coeffs() {
  // @@protoc_insertion_point(field_mutable_list:AdasOutputProtocol.Line.coeffs)
  return &coeffs_;
}

// repeated .AdasOutputProtocol.GroundPoint end_points = 5;
inline int Line::end_points_size() const {
  return end_points_.size();
}
inline void Line::clear_end_points() {
  end_points_.Clear();
}
inline const ::AdasOutputProtocol::GroundPoint& Line::end_points(int index) const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Line.end_points)
  return end_points_.Get(index);
}
inline ::AdasOutputProtocol::GroundPoint* Line::mutable_end_points(int index) {
  // @@protoc_insertion_point(field_mutable:AdasOutputProtocol.Line.end_points)
  return end_points_.Mutable(index);
}
inline ::AdasOutputProtocol::GroundPoint* Line::add_end_points() {
  // @@protoc_insertion_point(field_add:AdasOutputProtocol.Line.end_points)
  return end_points_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AdasOutputProtocol::GroundPoint >&
Line::end_points() const {
  // @@protoc_insertion_point(field_list:AdasOutputProtocol.Line.end_points)
  return end_points_;
}
inline ::google::protobuf::RepeatedPtrField< ::AdasOutputProtocol::GroundPoint >*
Line::mutable_end_points() {
  // @@protoc_insertion_point(field_mutable_list:AdasOutputProtocol.Line.end_points)
  return &end_points_;
}

// optional float line_cross_distance = 6;
inline bool Line::has_line_cross_distance() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Line::set_has_line_cross_distance() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Line::clear_has_line_cross_distance() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Line::clear_line_cross_distance() {
  line_cross_distance_ = 0;
  clear_has_line_cross_distance();
}
inline float Line::line_cross_distance() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Line.line_cross_distance)
  return line_cross_distance_;
}
inline void Line::set_line_cross_distance(float value) {
  set_has_line_cross_distance();
  line_cross_distance_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.Line.line_cross_distance)
}

// optional float ttlc = 7;
inline bool Line::has_ttlc() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Line::set_has_ttlc() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Line::clear_has_ttlc() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Line::clear_ttlc() {
  ttlc_ = 0;
  clear_has_ttlc();
}
inline float Line::ttlc() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Line.ttlc)
  return ttlc_;
}
inline void Line::set_ttlc(float value) {
  set_has_ttlc();
  ttlc_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.Line.ttlc)
}

// optional float depature_v = 8;
inline bool Line::has_depature_v() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Line::set_has_depature_v() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Line::clear_has_depature_v() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Line::clear_depature_v() {
  depature_v_ = 0;
  clear_has_depature_v();
}
inline float Line::depature_v() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Line.depature_v)
  return depature_v_;
}
inline void Line::set_depature_v(float value) {
  set_has_depature_v();
  depature_v_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.Line.depature_v)
}

// optional int64 tracking_time = 9;
inline bool Line::has_tracking_time() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Line::set_has_tracking_time() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Line::clear_has_tracking_time() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Line::clear_tracking_time() {
  tracking_time_ = GOOGLE_LONGLONG(0);
  clear_has_tracking_time();
}
inline ::google::protobuf::int64 Line::tracking_time() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Line.tracking_time)
  return tracking_time_;
}
inline void Line::set_tracking_time(::google::protobuf::int64 value) {
  set_has_tracking_time();
  tracking_time_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.Line.tracking_time)
}

// -------------------------------------------------------------------

// Object

// required int32 id = 1;
inline bool Object::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Object::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Object::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Object::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 Object::id() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Object.id)
  return id_;
}
inline void Object::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.Object.id)
}

// optional int32 type = 2;
inline bool Object::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Object::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Object::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Object::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 Object::type() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Object.type)
  return type_;
}
inline void Object::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.Object.type)
}

// optional int64 time_stamp = 3;
inline bool Object::has_time_stamp() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Object::set_has_time_stamp() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Object::clear_has_time_stamp() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Object::clear_time_stamp() {
  time_stamp_ = GOOGLE_LONGLONG(0);
  clear_has_time_stamp();
}
inline ::google::protobuf::int64 Object::time_stamp() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Object.time_stamp)
  return time_stamp_;
}
inline void Object::set_time_stamp(::google::protobuf::int64 value) {
  set_has_time_stamp();
  time_stamp_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.Object.time_stamp)
}

// optional .AdasOutputProtocol.GroundPoint relative_location = 4;
inline bool Object::has_relative_location() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Object::set_has_relative_location() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Object::clear_has_relative_location() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Object::clear_relative_location() {
  if (relative_location_ != NULL) relative_location_->::AdasOutputProtocol::GroundPoint::Clear();
  clear_has_relative_location();
}
inline const ::AdasOutputProtocol::GroundPoint& Object::relative_location() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Object.relative_location)
  return relative_location_ != NULL ? *relative_location_ : *default_instance_->relative_location_;
}
inline ::AdasOutputProtocol::GroundPoint* Object::mutable_relative_location() {
  set_has_relative_location();
  if (relative_location_ == NULL) relative_location_ = new ::AdasOutputProtocol::GroundPoint;
  // @@protoc_insertion_point(field_mutable:AdasOutputProtocol.Object.relative_location)
  return relative_location_;
}
inline ::AdasOutputProtocol::GroundPoint* Object::release_relative_location() {
  clear_has_relative_location();
  ::AdasOutputProtocol::GroundPoint* temp = relative_location_;
  relative_location_ = NULL;
  return temp;
}
inline void Object::set_allocated_relative_location(::AdasOutputProtocol::GroundPoint* relative_location) {
  delete relative_location_;
  relative_location_ = relative_location;
  if (relative_location) {
    set_has_relative_location();
  } else {
    clear_has_relative_location();
  }
  // @@protoc_insertion_point(field_set_allocated:AdasOutputProtocol.Object.relative_location)
}

// optional .AdasOutputProtocol.GroundPoint relative_velocity = 5;
inline bool Object::has_relative_velocity() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Object::set_has_relative_velocity() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Object::clear_has_relative_velocity() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Object::clear_relative_velocity() {
  if (relative_velocity_ != NULL) relative_velocity_->::AdasOutputProtocol::GroundPoint::Clear();
  clear_has_relative_velocity();
}
inline const ::AdasOutputProtocol::GroundPoint& Object::relative_velocity() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Object.relative_velocity)
  return relative_velocity_ != NULL ? *relative_velocity_ : *default_instance_->relative_velocity_;
}
inline ::AdasOutputProtocol::GroundPoint* Object::mutable_relative_velocity() {
  set_has_relative_velocity();
  if (relative_velocity_ == NULL) relative_velocity_ = new ::AdasOutputProtocol::GroundPoint;
  // @@protoc_insertion_point(field_mutable:AdasOutputProtocol.Object.relative_velocity)
  return relative_velocity_;
}
inline ::AdasOutputProtocol::GroundPoint* Object::release_relative_velocity() {
  clear_has_relative_velocity();
  ::AdasOutputProtocol::GroundPoint* temp = relative_velocity_;
  relative_velocity_ = NULL;
  return temp;
}
inline void Object::set_allocated_relative_velocity(::AdasOutputProtocol::GroundPoint* relative_velocity) {
  delete relative_velocity_;
  relative_velocity_ = relative_velocity;
  if (relative_velocity) {
    set_has_relative_velocity();
  } else {
    clear_has_relative_velocity();
  }
  // @@protoc_insertion_point(field_set_allocated:AdasOutputProtocol.Object.relative_velocity)
}

// optional float ttc = 6;
inline bool Object::has_ttc() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Object::set_has_ttc() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Object::clear_has_ttc() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Object::clear_ttc() {
  ttc_ = 0;
  clear_has_ttc();
}
inline float Object::ttc() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Object.ttc)
  return ttc_;
}
inline void Object::set_ttc(float value) {
  set_has_ttc();
  ttc_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.Object.ttc)
}

// optional .AdasOutputProtocol.Rect rect = 7;
inline bool Object::has_rect() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Object::set_has_rect() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Object::clear_has_rect() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Object::clear_rect() {
  if (rect_ != NULL) rect_->::AdasOutputProtocol::Rect::Clear();
  clear_has_rect();
}
inline const ::AdasOutputProtocol::Rect& Object::rect() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Object.rect)
  return rect_ != NULL ? *rect_ : *default_instance_->rect_;
}
inline ::AdasOutputProtocol::Rect* Object::mutable_rect() {
  set_has_rect();
  if (rect_ == NULL) rect_ = new ::AdasOutputProtocol::Rect;
  // @@protoc_insertion_point(field_mutable:AdasOutputProtocol.Object.rect)
  return rect_;
}
inline ::AdasOutputProtocol::Rect* Object::release_rect() {
  clear_has_rect();
  ::AdasOutputProtocol::Rect* temp = rect_;
  rect_ = NULL;
  return temp;
}
inline void Object::set_allocated_rect(::AdasOutputProtocol::Rect* rect) {
  delete rect_;
  rect_ = rect;
  if (rect) {
    set_has_rect();
  } else {
    clear_has_rect();
  }
  // @@protoc_insertion_point(field_set_allocated:AdasOutputProtocol.Object.rect)
}

// optional int64 tracking_time = 8;
inline bool Object::has_tracking_time() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Object::set_has_tracking_time() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Object::clear_has_tracking_time() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Object::clear_tracking_time() {
  tracking_time_ = GOOGLE_LONGLONG(0);
  clear_has_tracking_time();
}
inline ::google::protobuf::int64 Object::tracking_time() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Object.tracking_time)
  return tracking_time_;
}
inline void Object::set_tracking_time(::google::protobuf::int64 value) {
  set_has_tracking_time();
  tracking_time_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.Object.tracking_time)
}

// optional bool is_key_object = 9;
inline bool Object::has_is_key_object() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Object::set_has_is_key_object() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Object::clear_has_is_key_object() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Object::clear_is_key_object() {
  is_key_object_ = false;
  clear_has_is_key_object();
}
inline bool Object::is_key_object() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.Object.is_key_object)
  return is_key_object_;
}
inline void Object::set_is_key_object(bool value) {
  set_has_is_key_object();
  is_key_object_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.Object.is_key_object)
}

// -------------------------------------------------------------------

// HMW

// optional int32 function_status = 1;
inline bool HMW::has_function_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void HMW::set_has_function_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void HMW::clear_has_function_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void HMW::clear_function_status() {
  function_status_ = 0;
  clear_has_function_status();
}
inline ::google::protobuf::int32 HMW::function_status() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.HMW.function_status)
  return function_status_;
}
inline void HMW::set_function_status(::google::protobuf::int32 value) {
  set_has_function_status();
  function_status_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.HMW.function_status)
}

// optional int32 warning_level = 2;
inline bool HMW::has_warning_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void HMW::set_has_warning_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void HMW::clear_has_warning_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void HMW::clear_warning_level() {
  warning_level_ = 0;
  clear_has_warning_level();
}
inline ::google::protobuf::int32 HMW::warning_level() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.HMW.warning_level)
  return warning_level_;
}
inline void HMW::set_warning_level(::google::protobuf::int32 value) {
  set_has_warning_level();
  warning_level_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.HMW.warning_level)
}

// optional float time_to_conllision = 3;
inline bool HMW::has_time_to_conllision() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void HMW::set_has_time_to_conllision() {
  _has_bits_[0] |= 0x00000004u;
}
inline void HMW::clear_has_time_to_conllision() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void HMW::clear_time_to_conllision() {
  time_to_conllision_ = 0;
  clear_has_time_to_conllision();
}
inline float HMW::time_to_conllision() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.HMW.time_to_conllision)
  return time_to_conllision_;
}
inline void HMW::set_time_to_conllision(float value) {
  set_has_time_to_conllision();
  time_to_conllision_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.HMW.time_to_conllision)
}

// optional int32 object_type = 4;
inline bool HMW::has_object_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void HMW::set_has_object_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void HMW::clear_has_object_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void HMW::clear_object_type() {
  object_type_ = 0;
  clear_has_object_type();
}
inline ::google::protobuf::int32 HMW::object_type() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.HMW.object_type)
  return object_type_;
}
inline void HMW::set_object_type(::google::protobuf::int32 value) {
  set_has_object_type();
  object_type_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.HMW.object_type)
}

// optional int32 veh_id = 5;
inline bool HMW::has_veh_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void HMW::set_has_veh_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void HMW::clear_has_veh_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void HMW::clear_veh_id() {
  veh_id_ = 0;
  clear_has_veh_id();
}
inline ::google::protobuf::int32 HMW::veh_id() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.HMW.veh_id)
  return veh_id_;
}
inline void HMW::set_veh_id(::google::protobuf::int32 value) {
  set_has_veh_id();
  veh_id_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.HMW.veh_id)
}

// -------------------------------------------------------------------

// FCW

// optional int32 function_status = 1;
inline bool FCW::has_function_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FCW::set_has_function_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FCW::clear_has_function_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FCW::clear_function_status() {
  function_status_ = 0;
  clear_has_function_status();
}
inline ::google::protobuf::int32 FCW::function_status() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.FCW.function_status)
  return function_status_;
}
inline void FCW::set_function_status(::google::protobuf::int32 value) {
  set_has_function_status();
  function_status_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.FCW.function_status)
}

// optional int32 warning_level = 2;
inline bool FCW::has_warning_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FCW::set_has_warning_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FCW::clear_has_warning_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FCW::clear_warning_level() {
  warning_level_ = 0;
  clear_has_warning_level();
}
inline ::google::protobuf::int32 FCW::warning_level() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.FCW.warning_level)
  return warning_level_;
}
inline void FCW::set_warning_level(::google::protobuf::int32 value) {
  set_has_warning_level();
  warning_level_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.FCW.warning_level)
}

// optional float time_to_conllision = 3;
inline bool FCW::has_time_to_conllision() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void FCW::set_has_time_to_conllision() {
  _has_bits_[0] |= 0x00000004u;
}
inline void FCW::clear_has_time_to_conllision() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void FCW::clear_time_to_conllision() {
  time_to_conllision_ = 0;
  clear_has_time_to_conllision();
}
inline float FCW::time_to_conllision() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.FCW.time_to_conllision)
  return time_to_conllision_;
}
inline void FCW::set_time_to_conllision(float value) {
  set_has_time_to_conllision();
  time_to_conllision_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.FCW.time_to_conllision)
}

// optional int32 object_type = 4;
inline bool FCW::has_object_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void FCW::set_has_object_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void FCW::clear_has_object_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void FCW::clear_object_type() {
  object_type_ = 0;
  clear_has_object_type();
}
inline ::google::protobuf::int32 FCW::object_type() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.FCW.object_type)
  return object_type_;
}
inline void FCW::set_object_type(::google::protobuf::int32 value) {
  set_has_object_type();
  object_type_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.FCW.object_type)
}

// optional int32 veh_id = 5;
inline bool FCW::has_veh_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void FCW::set_has_veh_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void FCW::clear_has_veh_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void FCW::clear_veh_id() {
  veh_id_ = 0;
  clear_has_veh_id();
}
inline ::google::protobuf::int32 FCW::veh_id() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.FCW.veh_id)
  return veh_id_;
}
inline void FCW::set_veh_id(::google::protobuf::int32 value) {
  set_has_veh_id();
  veh_id_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.FCW.veh_id)
}

// -------------------------------------------------------------------

// PCW

// optional int32 function_status = 1;
inline bool PCW::has_function_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PCW::set_has_function_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PCW::clear_has_function_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PCW::clear_function_status() {
  function_status_ = 0;
  clear_has_function_status();
}
inline ::google::protobuf::int32 PCW::function_status() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.PCW.function_status)
  return function_status_;
}
inline void PCW::set_function_status(::google::protobuf::int32 value) {
  set_has_function_status();
  function_status_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.PCW.function_status)
}

// optional int32 warning_level = 2;
inline bool PCW::has_warning_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PCW::set_has_warning_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PCW::clear_has_warning_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PCW::clear_warning_level() {
  warning_level_ = 0;
  clear_has_warning_level();
}
inline ::google::protobuf::int32 PCW::warning_level() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.PCW.warning_level)
  return warning_level_;
}
inline void PCW::set_warning_level(::google::protobuf::int32 value) {
  set_has_warning_level();
  warning_level_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.PCW.warning_level)
}

// optional float time_to_conllision = 3;
inline bool PCW::has_time_to_conllision() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PCW::set_has_time_to_conllision() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PCW::clear_has_time_to_conllision() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PCW::clear_time_to_conllision() {
  time_to_conllision_ = 0;
  clear_has_time_to_conllision();
}
inline float PCW::time_to_conllision() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.PCW.time_to_conllision)
  return time_to_conllision_;
}
inline void PCW::set_time_to_conllision(float value) {
  set_has_time_to_conllision();
  time_to_conllision_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.PCW.time_to_conllision)
}

// optional int32 object_type = 4;
inline bool PCW::has_object_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PCW::set_has_object_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PCW::clear_has_object_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PCW::clear_object_type() {
  object_type_ = 0;
  clear_has_object_type();
}
inline ::google::protobuf::int32 PCW::object_type() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.PCW.object_type)
  return object_type_;
}
inline void PCW::set_object_type(::google::protobuf::int32 value) {
  set_has_object_type();
  object_type_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.PCW.object_type)
}

// optional int32 ped_id = 5;
inline bool PCW::has_ped_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PCW::set_has_ped_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PCW::clear_has_ped_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PCW::clear_ped_id() {
  ped_id_ = 0;
  clear_has_ped_id();
}
inline ::google::protobuf::int32 PCW::ped_id() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.PCW.ped_id)
  return ped_id_;
}
inline void PCW::set_ped_id(::google::protobuf::int32 value) {
  set_has_ped_id();
  ped_id_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.PCW.ped_id)
}

// -------------------------------------------------------------------

// LDW

// optional int32 function_status = 1;
inline bool LDW::has_function_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LDW::set_has_function_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LDW::clear_has_function_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LDW::clear_function_status() {
  function_status_ = 0;
  clear_has_function_status();
}
inline ::google::protobuf::int32 LDW::function_status() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.LDW.function_status)
  return function_status_;
}
inline void LDW::set_function_status(::google::protobuf::int32 value) {
  set_has_function_status();
  function_status_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.LDW.function_status)
}

// optional int32 warning_level = 2;
inline bool LDW::has_warning_level() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LDW::set_has_warning_level() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LDW::clear_has_warning_level() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LDW::clear_warning_level() {
  warning_level_ = 0;
  clear_has_warning_level();
}
inline ::google::protobuf::int32 LDW::warning_level() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.LDW.warning_level)
  return warning_level_;
}
inline void LDW::set_warning_level(::google::protobuf::int32 value) {
  set_has_warning_level();
  warning_level_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.LDW.warning_level)
}

// optional float line_cross_distance = 3;
inline bool LDW::has_line_cross_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LDW::set_has_line_cross_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LDW::clear_has_line_cross_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LDW::clear_line_cross_distance() {
  line_cross_distance_ = 0;
  clear_has_line_cross_distance();
}
inline float LDW::line_cross_distance() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.LDW.line_cross_distance)
  return line_cross_distance_;
}
inline void LDW::set_line_cross_distance(float value) {
  set_has_line_cross_distance();
  line_cross_distance_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.LDW.line_cross_distance)
}

// optional int32 object_type = 4;
inline bool LDW::has_object_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LDW::set_has_object_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LDW::clear_has_object_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LDW::clear_object_type() {
  object_type_ = 0;
  clear_has_object_type();
}
inline ::google::protobuf::int32 LDW::object_type() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.LDW.object_type)
  return object_type_;
}
inline void LDW::set_object_type(::google::protobuf::int32 value) {
  set_has_object_type();
  object_type_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.LDW.object_type)
}

// optional int32 line_id = 5;
inline bool LDW::has_line_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LDW::set_has_line_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LDW::clear_has_line_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LDW::clear_line_id() {
  line_id_ = 0;
  clear_has_line_id();
}
inline ::google::protobuf::int32 LDW::line_id() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.LDW.line_id)
  return line_id_;
}
inline void LDW::set_line_id(::google::protobuf::int32 value) {
  set_has_line_id();
  line_id_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.LDW.line_id)
}

// -------------------------------------------------------------------

// WarningResult

// optional .AdasOutputProtocol.HMW hmw = 1;
inline bool WarningResult::has_hmw() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WarningResult::set_has_hmw() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WarningResult::clear_has_hmw() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WarningResult::clear_hmw() {
  if (hmw_ != NULL) hmw_->::AdasOutputProtocol::HMW::Clear();
  clear_has_hmw();
}
inline const ::AdasOutputProtocol::HMW& WarningResult::hmw() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.WarningResult.hmw)
  return hmw_ != NULL ? *hmw_ : *default_instance_->hmw_;
}
inline ::AdasOutputProtocol::HMW* WarningResult::mutable_hmw() {
  set_has_hmw();
  if (hmw_ == NULL) hmw_ = new ::AdasOutputProtocol::HMW;
  // @@protoc_insertion_point(field_mutable:AdasOutputProtocol.WarningResult.hmw)
  return hmw_;
}
inline ::AdasOutputProtocol::HMW* WarningResult::release_hmw() {
  clear_has_hmw();
  ::AdasOutputProtocol::HMW* temp = hmw_;
  hmw_ = NULL;
  return temp;
}
inline void WarningResult::set_allocated_hmw(::AdasOutputProtocol::HMW* hmw) {
  delete hmw_;
  hmw_ = hmw;
  if (hmw) {
    set_has_hmw();
  } else {
    clear_has_hmw();
  }
  // @@protoc_insertion_point(field_set_allocated:AdasOutputProtocol.WarningResult.hmw)
}

// optional .AdasOutputProtocol.FCW fcw = 2;
inline bool WarningResult::has_fcw() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WarningResult::set_has_fcw() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WarningResult::clear_has_fcw() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WarningResult::clear_fcw() {
  if (fcw_ != NULL) fcw_->::AdasOutputProtocol::FCW::Clear();
  clear_has_fcw();
}
inline const ::AdasOutputProtocol::FCW& WarningResult::fcw() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.WarningResult.fcw)
  return fcw_ != NULL ? *fcw_ : *default_instance_->fcw_;
}
inline ::AdasOutputProtocol::FCW* WarningResult::mutable_fcw() {
  set_has_fcw();
  if (fcw_ == NULL) fcw_ = new ::AdasOutputProtocol::FCW;
  // @@protoc_insertion_point(field_mutable:AdasOutputProtocol.WarningResult.fcw)
  return fcw_;
}
inline ::AdasOutputProtocol::FCW* WarningResult::release_fcw() {
  clear_has_fcw();
  ::AdasOutputProtocol::FCW* temp = fcw_;
  fcw_ = NULL;
  return temp;
}
inline void WarningResult::set_allocated_fcw(::AdasOutputProtocol::FCW* fcw) {
  delete fcw_;
  fcw_ = fcw;
  if (fcw) {
    set_has_fcw();
  } else {
    clear_has_fcw();
  }
  // @@protoc_insertion_point(field_set_allocated:AdasOutputProtocol.WarningResult.fcw)
}

// optional .AdasOutputProtocol.LDW ldw = 3;
inline bool WarningResult::has_ldw() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WarningResult::set_has_ldw() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WarningResult::clear_has_ldw() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WarningResult::clear_ldw() {
  if (ldw_ != NULL) ldw_->::AdasOutputProtocol::LDW::Clear();
  clear_has_ldw();
}
inline const ::AdasOutputProtocol::LDW& WarningResult::ldw() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.WarningResult.ldw)
  return ldw_ != NULL ? *ldw_ : *default_instance_->ldw_;
}
inline ::AdasOutputProtocol::LDW* WarningResult::mutable_ldw() {
  set_has_ldw();
  if (ldw_ == NULL) ldw_ = new ::AdasOutputProtocol::LDW;
  // @@protoc_insertion_point(field_mutable:AdasOutputProtocol.WarningResult.ldw)
  return ldw_;
}
inline ::AdasOutputProtocol::LDW* WarningResult::release_ldw() {
  clear_has_ldw();
  ::AdasOutputProtocol::LDW* temp = ldw_;
  ldw_ = NULL;
  return temp;
}
inline void WarningResult::set_allocated_ldw(::AdasOutputProtocol::LDW* ldw) {
  delete ldw_;
  ldw_ = ldw;
  if (ldw) {
    set_has_ldw();
  } else {
    clear_has_ldw();
  }
  // @@protoc_insertion_point(field_set_allocated:AdasOutputProtocol.WarningResult.ldw)
}

// optional .AdasOutputProtocol.PCW pcw = 4;
inline bool WarningResult::has_pcw() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WarningResult::set_has_pcw() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WarningResult::clear_has_pcw() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WarningResult::clear_pcw() {
  if (pcw_ != NULL) pcw_->::AdasOutputProtocol::PCW::Clear();
  clear_has_pcw();
}
inline const ::AdasOutputProtocol::PCW& WarningResult::pcw() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.WarningResult.pcw)
  return pcw_ != NULL ? *pcw_ : *default_instance_->pcw_;
}
inline ::AdasOutputProtocol::PCW* WarningResult::mutable_pcw() {
  set_has_pcw();
  if (pcw_ == NULL) pcw_ = new ::AdasOutputProtocol::PCW;
  // @@protoc_insertion_point(field_mutable:AdasOutputProtocol.WarningResult.pcw)
  return pcw_;
}
inline ::AdasOutputProtocol::PCW* WarningResult::release_pcw() {
  clear_has_pcw();
  ::AdasOutputProtocol::PCW* temp = pcw_;
  pcw_ = NULL;
  return temp;
}
inline void WarningResult::set_allocated_pcw(::AdasOutputProtocol::PCW* pcw) {
  delete pcw_;
  pcw_ = pcw;
  if (pcw) {
    set_has_pcw();
  } else {
    clear_has_pcw();
  }
  // @@protoc_insertion_point(field_set_allocated:AdasOutputProtocol.WarningResult.pcw)
}

// optional int32 warning_type = 5;
inline bool WarningResult::has_warning_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WarningResult::set_has_warning_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WarningResult::clear_has_warning_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WarningResult::clear_warning_type() {
  warning_type_ = 0;
  clear_has_warning_type();
}
inline ::google::protobuf::int32 WarningResult::warning_type() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.WarningResult.warning_type)
  return warning_type_;
}
inline void WarningResult::set_warning_type(::google::protobuf::int32 value) {
  set_has_warning_type();
  warning_type_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.WarningResult.warning_type)
}

// -------------------------------------------------------------------

// AdasOutput

// required int32 version = 1;
inline bool AdasOutput::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AdasOutput::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AdasOutput::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AdasOutput::clear_version() {
  version_ = 0;
  clear_has_version();
}
inline ::google::protobuf::int32 AdasOutput::version() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.AdasOutput.version)
  return version_;
}
inline void AdasOutput::set_version(::google::protobuf::int32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.AdasOutput.version)
}

// required int32 frame_id = 2;
inline bool AdasOutput::has_frame_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AdasOutput::set_has_frame_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AdasOutput::clear_has_frame_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AdasOutput::clear_frame_id() {
  frame_id_ = 0;
  clear_has_frame_id();
}
inline ::google::protobuf::int32 AdasOutput::frame_id() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.AdasOutput.frame_id)
  return frame_id_;
}
inline void AdasOutput::set_frame_id(::google::protobuf::int32 value) {
  set_has_frame_id();
  frame_id_ = value;
  // @@protoc_insertion_point(field_set:AdasOutputProtocol.AdasOutput.frame_id)
}

// optional .AdasOutputProtocol.CameraInfo camera = 3;
inline bool AdasOutput::has_camera() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AdasOutput::set_has_camera() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AdasOutput::clear_has_camera() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AdasOutput::clear_camera() {
  if (camera_ != NULL) camera_->::AdasOutputProtocol::CameraInfo::Clear();
  clear_has_camera();
}
inline const ::AdasOutputProtocol::CameraInfo& AdasOutput::camera() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.AdasOutput.camera)
  return camera_ != NULL ? *camera_ : *default_instance_->camera_;
}
inline ::AdasOutputProtocol::CameraInfo* AdasOutput::mutable_camera() {
  set_has_camera();
  if (camera_ == NULL) camera_ = new ::AdasOutputProtocol::CameraInfo;
  // @@protoc_insertion_point(field_mutable:AdasOutputProtocol.AdasOutput.camera)
  return camera_;
}
inline ::AdasOutputProtocol::CameraInfo* AdasOutput::release_camera() {
  clear_has_camera();
  ::AdasOutputProtocol::CameraInfo* temp = camera_;
  camera_ = NULL;
  return temp;
}
inline void AdasOutput::set_allocated_camera(::AdasOutputProtocol::CameraInfo* camera) {
  delete camera_;
  camera_ = camera;
  if (camera) {
    set_has_camera();
  } else {
    clear_has_camera();
  }
  // @@protoc_insertion_point(field_set_allocated:AdasOutputProtocol.AdasOutput.camera)
}

// optional .AdasOutputProtocol.ImageFrame image = 4;
inline bool AdasOutput::has_image() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AdasOutput::set_has_image() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AdasOutput::clear_has_image() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AdasOutput::clear_image() {
  if (image_ != NULL) image_->::AdasOutputProtocol::ImageFrame::Clear();
  clear_has_image();
}
inline const ::AdasOutputProtocol::ImageFrame& AdasOutput::image() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.AdasOutput.image)
  return image_ != NULL ? *image_ : *default_instance_->image_;
}
inline ::AdasOutputProtocol::ImageFrame* AdasOutput::mutable_image() {
  set_has_image();
  if (image_ == NULL) image_ = new ::AdasOutputProtocol::ImageFrame;
  // @@protoc_insertion_point(field_mutable:AdasOutputProtocol.AdasOutput.image)
  return image_;
}
inline ::AdasOutputProtocol::ImageFrame* AdasOutput::release_image() {
  clear_has_image();
  ::AdasOutputProtocol::ImageFrame* temp = image_;
  image_ = NULL;
  return temp;
}
inline void AdasOutput::set_allocated_image(::AdasOutputProtocol::ImageFrame* image) {
  delete image_;
  image_ = image;
  if (image) {
    set_has_image();
  } else {
    clear_has_image();
  }
  // @@protoc_insertion_point(field_set_allocated:AdasOutputProtocol.AdasOutput.image)
}

// optional .AdasOutputProtocol.GPS gps = 5;
inline bool AdasOutput::has_gps() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AdasOutput::set_has_gps() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AdasOutput::clear_has_gps() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AdasOutput::clear_gps() {
  if (gps_ != NULL) gps_->::AdasOutputProtocol::GPS::Clear();
  clear_has_gps();
}
inline const ::AdasOutputProtocol::GPS& AdasOutput::gps() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.AdasOutput.gps)
  return gps_ != NULL ? *gps_ : *default_instance_->gps_;
}
inline ::AdasOutputProtocol::GPS* AdasOutput::mutable_gps() {
  set_has_gps();
  if (gps_ == NULL) gps_ = new ::AdasOutputProtocol::GPS;
  // @@protoc_insertion_point(field_mutable:AdasOutputProtocol.AdasOutput.gps)
  return gps_;
}
inline ::AdasOutputProtocol::GPS* AdasOutput::release_gps() {
  clear_has_gps();
  ::AdasOutputProtocol::GPS* temp = gps_;
  gps_ = NULL;
  return temp;
}
inline void AdasOutput::set_allocated_gps(::AdasOutputProtocol::GPS* gps) {
  delete gps_;
  gps_ = gps;
  if (gps) {
    set_has_gps();
  } else {
    clear_has_gps();
  }
  // @@protoc_insertion_point(field_set_allocated:AdasOutputProtocol.AdasOutput.gps)
}

// optional .AdasOutputProtocol.Motion motion = 6;
inline bool AdasOutput::has_motion() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AdasOutput::set_has_motion() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AdasOutput::clear_has_motion() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AdasOutput::clear_motion() {
  if (motion_ != NULL) motion_->::AdasOutputProtocol::Motion::Clear();
  clear_has_motion();
}
inline const ::AdasOutputProtocol::Motion& AdasOutput::motion() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.AdasOutput.motion)
  return motion_ != NULL ? *motion_ : *default_instance_->motion_;
}
inline ::AdasOutputProtocol::Motion* AdasOutput::mutable_motion() {
  set_has_motion();
  if (motion_ == NULL) motion_ = new ::AdasOutputProtocol::Motion;
  // @@protoc_insertion_point(field_mutable:AdasOutputProtocol.AdasOutput.motion)
  return motion_;
}
inline ::AdasOutputProtocol::Motion* AdasOutput::release_motion() {
  clear_has_motion();
  ::AdasOutputProtocol::Motion* temp = motion_;
  motion_ = NULL;
  return temp;
}
inline void AdasOutput::set_allocated_motion(::AdasOutputProtocol::Motion* motion) {
  delete motion_;
  motion_ = motion;
  if (motion) {
    set_has_motion();
  } else {
    clear_has_motion();
  }
  // @@protoc_insertion_point(field_set_allocated:AdasOutputProtocol.AdasOutput.motion)
}

// repeated .AdasOutputProtocol.Object vehicles = 7;
inline int AdasOutput::vehicles_size() const {
  return vehicles_.size();
}
inline void AdasOutput::clear_vehicles() {
  vehicles_.Clear();
}
inline const ::AdasOutputProtocol::Object& AdasOutput::vehicles(int index) const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.AdasOutput.vehicles)
  return vehicles_.Get(index);
}
inline ::AdasOutputProtocol::Object* AdasOutput::mutable_vehicles(int index) {
  // @@protoc_insertion_point(field_mutable:AdasOutputProtocol.AdasOutput.vehicles)
  return vehicles_.Mutable(index);
}
inline ::AdasOutputProtocol::Object* AdasOutput::add_vehicles() {
  // @@protoc_insertion_point(field_add:AdasOutputProtocol.AdasOutput.vehicles)
  return vehicles_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AdasOutputProtocol::Object >&
AdasOutput::vehicles() const {
  // @@protoc_insertion_point(field_list:AdasOutputProtocol.AdasOutput.vehicles)
  return vehicles_;
}
inline ::google::protobuf::RepeatedPtrField< ::AdasOutputProtocol::Object >*
AdasOutput::mutable_vehicles() {
  // @@protoc_insertion_point(field_mutable_list:AdasOutputProtocol.AdasOutput.vehicles)
  return &vehicles_;
}

// repeated .AdasOutputProtocol.Object pedestrians = 8;
inline int AdasOutput::pedestrians_size() const {
  return pedestrians_.size();
}
inline void AdasOutput::clear_pedestrians() {
  pedestrians_.Clear();
}
inline const ::AdasOutputProtocol::Object& AdasOutput::pedestrians(int index) const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.AdasOutput.pedestrians)
  return pedestrians_.Get(index);
}
inline ::AdasOutputProtocol::Object* AdasOutput::mutable_pedestrians(int index) {
  // @@protoc_insertion_point(field_mutable:AdasOutputProtocol.AdasOutput.pedestrians)
  return pedestrians_.Mutable(index);
}
inline ::AdasOutputProtocol::Object* AdasOutput::add_pedestrians() {
  // @@protoc_insertion_point(field_add:AdasOutputProtocol.AdasOutput.pedestrians)
  return pedestrians_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AdasOutputProtocol::Object >&
AdasOutput::pedestrians() const {
  // @@protoc_insertion_point(field_list:AdasOutputProtocol.AdasOutput.pedestrians)
  return pedestrians_;
}
inline ::google::protobuf::RepeatedPtrField< ::AdasOutputProtocol::Object >*
AdasOutput::mutable_pedestrians() {
  // @@protoc_insertion_point(field_mutable_list:AdasOutputProtocol.AdasOutput.pedestrians)
  return &pedestrians_;
}

// repeated .AdasOutputProtocol.Line lines = 9;
inline int AdasOutput::lines_size() const {
  return lines_.size();
}
inline void AdasOutput::clear_lines() {
  lines_.Clear();
}
inline const ::AdasOutputProtocol::Line& AdasOutput::lines(int index) const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.AdasOutput.lines)
  return lines_.Get(index);
}
inline ::AdasOutputProtocol::Line* AdasOutput::mutable_lines(int index) {
  // @@protoc_insertion_point(field_mutable:AdasOutputProtocol.AdasOutput.lines)
  return lines_.Mutable(index);
}
inline ::AdasOutputProtocol::Line* AdasOutput::add_lines() {
  // @@protoc_insertion_point(field_add:AdasOutputProtocol.AdasOutput.lines)
  return lines_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::AdasOutputProtocol::Line >&
AdasOutput::lines() const {
  // @@protoc_insertion_point(field_list:AdasOutputProtocol.AdasOutput.lines)
  return lines_;
}
inline ::google::protobuf::RepeatedPtrField< ::AdasOutputProtocol::Line >*
AdasOutput::mutable_lines() {
  // @@protoc_insertion_point(field_mutable_list:AdasOutputProtocol.AdasOutput.lines)
  return &lines_;
}

// optional .AdasOutputProtocol.WarningResult warning_result = 10;
inline bool AdasOutput::has_warning_result() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void AdasOutput::set_has_warning_result() {
  _has_bits_[0] |= 0x00000200u;
}
inline void AdasOutput::clear_has_warning_result() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void AdasOutput::clear_warning_result() {
  if (warning_result_ != NULL) warning_result_->::AdasOutputProtocol::WarningResult::Clear();
  clear_has_warning_result();
}
inline const ::AdasOutputProtocol::WarningResult& AdasOutput::warning_result() const {
  // @@protoc_insertion_point(field_get:AdasOutputProtocol.AdasOutput.warning_result)
  return warning_result_ != NULL ? *warning_result_ : *default_instance_->warning_result_;
}
inline ::AdasOutputProtocol::WarningResult* AdasOutput::mutable_warning_result() {
  set_has_warning_result();
  if (warning_result_ == NULL) warning_result_ = new ::AdasOutputProtocol::WarningResult;
  // @@protoc_insertion_point(field_mutable:AdasOutputProtocol.AdasOutput.warning_result)
  return warning_result_;
}
inline ::AdasOutputProtocol::WarningResult* AdasOutput::release_warning_result() {
  clear_has_warning_result();
  ::AdasOutputProtocol::WarningResult* temp = warning_result_;
  warning_result_ = NULL;
  return temp;
}
inline void AdasOutput::set_allocated_warning_result(::AdasOutputProtocol::WarningResult* warning_result) {
  delete warning_result_;
  warning_result_ = warning_result;
  if (warning_result) {
    set_has_warning_result();
  } else {
    clear_has_warning_result();
  }
  // @@protoc_insertion_point(field_set_allocated:AdasOutputProtocol.AdasOutput.warning_result)
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace AdasOutputProtocol

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::AdasOutputProtocol::HMW_HmwLevel> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AdasOutputProtocol::HMW_HmwLevel>() {
  return ::AdasOutputProtocol::HMW_HmwLevel_descriptor();
}
template <> struct is_proto_enum< ::AdasOutputProtocol::FCW_FcwLevel> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AdasOutputProtocol::FCW_FcwLevel>() {
  return ::AdasOutputProtocol::FCW_FcwLevel_descriptor();
}
template <> struct is_proto_enum< ::AdasOutputProtocol::PCW_PcwLevel> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AdasOutputProtocol::PCW_PcwLevel>() {
  return ::AdasOutputProtocol::PCW_PcwLevel_descriptor();
}
template <> struct is_proto_enum< ::AdasOutputProtocol::LDW_LdwLevel> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AdasOutputProtocol::LDW_LdwLevel>() {
  return ::AdasOutputProtocol::LDW_LdwLevel_descriptor();
}
template <> struct is_proto_enum< ::AdasOutputProtocol::ImageFormat> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AdasOutputProtocol::ImageFormat>() {
  return ::AdasOutputProtocol::ImageFormat_descriptor();
}
template <> struct is_proto_enum< ::AdasOutputProtocol::LineType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AdasOutputProtocol::LineType>() {
  return ::AdasOutputProtocol::LineType_descriptor();
}
template <> struct is_proto_enum< ::AdasOutputProtocol::FunctionStatus> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AdasOutputProtocol::FunctionStatus>() {
  return ::AdasOutputProtocol::FunctionStatus_descriptor();
}
template <> struct is_proto_enum< ::AdasOutputProtocol::WarningLevel> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AdasOutputProtocol::WarningLevel>() {
  return ::AdasOutputProtocol::WarningLevel_descriptor();
}
template <> struct is_proto_enum< ::AdasOutputProtocol::WarningType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::AdasOutputProtocol::WarningType>() {
  return ::AdasOutputProtocol::WarningType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_adas_5foutput_2eproto__INCLUDED
