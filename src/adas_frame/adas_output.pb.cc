// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: adas_output.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "adas_output.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace AdasOutputProtocol {

namespace {

const ::google::protobuf::Descriptor* GroundPoint_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GroundPoint_reflection_ = NULL;
const ::google::protobuf::Descriptor* Rect_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Rect_reflection_ = NULL;
const ::google::protobuf::Descriptor* CameraInfo_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CameraInfo_reflection_ = NULL;
const ::google::protobuf::Descriptor* ImageFrame_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ImageFrame_reflection_ = NULL;
const ::google::protobuf::Descriptor* GPS_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  GPS_reflection_ = NULL;
const ::google::protobuf::Descriptor* Motion_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Motion_reflection_ = NULL;
const ::google::protobuf::Descriptor* Line_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Line_reflection_ = NULL;
const ::google::protobuf::Descriptor* Object_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Object_reflection_ = NULL;
const ::google::protobuf::Descriptor* HMW_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  HMW_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* HMW_HmwLevel_descriptor_ = NULL;
const ::google::protobuf::Descriptor* FCW_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FCW_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* FCW_FcwLevel_descriptor_ = NULL;
const ::google::protobuf::Descriptor* PCW_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PCW_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* PCW_PcwLevel_descriptor_ = NULL;
const ::google::protobuf::Descriptor* LDW_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LDW_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* LDW_LdwLevel_descriptor_ = NULL;
const ::google::protobuf::Descriptor* WarningResult_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  WarningResult_reflection_ = NULL;
const ::google::protobuf::Descriptor* AdasOutput_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AdasOutput_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* ImageFormat_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* LineType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* FunctionStatus_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* WarningLevel_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* WarningType_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_adas_5foutput_2eproto() {
  protobuf_AddDesc_adas_5foutput_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "adas_output.proto");
  GOOGLE_CHECK(file != NULL);
  GroundPoint_descriptor_ = file->message_type(0);
  static const int GroundPoint_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GroundPoint, x_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GroundPoint, z_),
  };
  GroundPoint_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GroundPoint_descriptor_,
      GroundPoint::default_instance_,
      GroundPoint_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GroundPoint, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GroundPoint, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GroundPoint));
  Rect_descriptor_ = file->message_type(1);
  static const int Rect_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Rect, left_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Rect, top_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Rect, right_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Rect, bottom_),
  };
  Rect_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Rect_descriptor_,
      Rect::default_instance_,
      Rect_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Rect, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Rect, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Rect));
  CameraInfo_descriptor_ = file->message_type(2);
  static const int CameraInfo_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraInfo, m__),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraInfo, minv__),
  };
  CameraInfo_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CameraInfo_descriptor_,
      CameraInfo::default_instance_,
      CameraInfo_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraInfo, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CameraInfo, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CameraInfo));
  ImageFrame_descriptor_ = file->message_type(3);
  static const int ImageFrame_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageFrame, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageFrame, height_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageFrame, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageFrame, channel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageFrame, send_mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageFrame, format_),
  };
  ImageFrame_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ImageFrame_descriptor_,
      ImageFrame::default_instance_,
      ImageFrame_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageFrame, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ImageFrame, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ImageFrame));
  GPS_descriptor_ = file->message_type(4);
  static const int GPS_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPS, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPS, longitude_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPS, latitude_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPS, altitude_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPS, gps_time_),
  };
  GPS_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      GPS_descriptor_,
      GPS::default_instance_,
      GPS_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPS, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(GPS, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(GPS));
  Motion_descriptor_ = file->message_type(5);
  static const int Motion_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Motion, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Motion, velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Motion, yaw_rate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Motion, acc_),
  };
  Motion_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Motion_descriptor_,
      Motion::default_instance_,
      Motion_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Motion, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Motion, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Motion));
  Line_descriptor_ = file->message_type(6);
  static const int Line_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, coeffs_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, end_points_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, line_cross_distance_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, ttlc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, depature_v_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, tracking_time_),
  };
  Line_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Line_descriptor_,
      Line::default_instance_,
      Line_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Line, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Line));
  Object_descriptor_ = file->message_type(7);
  static const int Object_offsets_[9] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Object, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Object, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Object, time_stamp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Object, relative_location_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Object, relative_velocity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Object, ttc_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Object, rect_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Object, tracking_time_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Object, is_key_object_),
  };
  Object_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Object_descriptor_,
      Object::default_instance_,
      Object_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Object, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Object, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Object));
  HMW_descriptor_ = file->message_type(8);
  static const int HMW_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HMW, function_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HMW, warning_level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HMW, time_to_conllision_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HMW, object_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HMW, veh_id_),
  };
  HMW_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      HMW_descriptor_,
      HMW::default_instance_,
      HMW_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HMW, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(HMW, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(HMW));
  HMW_HmwLevel_descriptor_ = HMW_descriptor_->enum_type(0);
  FCW_descriptor_ = file->message_type(9);
  static const int FCW_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FCW, function_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FCW, warning_level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FCW, time_to_conllision_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FCW, object_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FCW, veh_id_),
  };
  FCW_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FCW_descriptor_,
      FCW::default_instance_,
      FCW_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FCW, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FCW, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FCW));
  FCW_FcwLevel_descriptor_ = FCW_descriptor_->enum_type(0);
  PCW_descriptor_ = file->message_type(10);
  static const int PCW_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PCW, function_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PCW, warning_level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PCW, time_to_conllision_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PCW, object_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PCW, ped_id_),
  };
  PCW_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PCW_descriptor_,
      PCW::default_instance_,
      PCW_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PCW, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PCW, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PCW));
  PCW_PcwLevel_descriptor_ = PCW_descriptor_->enum_type(0);
  LDW_descriptor_ = file->message_type(11);
  static const int LDW_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LDW, function_status_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LDW, warning_level_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LDW, line_cross_distance_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LDW, object_type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LDW, line_id_),
  };
  LDW_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LDW_descriptor_,
      LDW::default_instance_,
      LDW_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LDW, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LDW, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LDW));
  LDW_LdwLevel_descriptor_ = LDW_descriptor_->enum_type(0);
  WarningResult_descriptor_ = file->message_type(12);
  static const int WarningResult_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WarningResult, hmw_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WarningResult, fcw_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WarningResult, ldw_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WarningResult, pcw_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WarningResult, warning_type_),
  };
  WarningResult_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      WarningResult_descriptor_,
      WarningResult::default_instance_,
      WarningResult_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WarningResult, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(WarningResult, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(WarningResult));
  AdasOutput_descriptor_ = file->message_type(13);
  static const int AdasOutput_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdasOutput, version_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdasOutput, frame_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdasOutput, camera_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdasOutput, image_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdasOutput, gps_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdasOutput, motion_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdasOutput, vehicles_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdasOutput, pedestrians_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdasOutput, lines_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdasOutput, warning_result_),
  };
  AdasOutput_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      AdasOutput_descriptor_,
      AdasOutput::default_instance_,
      AdasOutput_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdasOutput, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AdasOutput, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(AdasOutput));
  ImageFormat_descriptor_ = file->enum_type(0);
  LineType_descriptor_ = file->enum_type(1);
  FunctionStatus_descriptor_ = file->enum_type(2);
  WarningLevel_descriptor_ = file->enum_type(3);
  WarningType_descriptor_ = file->enum_type(4);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_adas_5foutput_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GroundPoint_descriptor_, &GroundPoint::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Rect_descriptor_, &Rect::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CameraInfo_descriptor_, &CameraInfo::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ImageFrame_descriptor_, &ImageFrame::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    GPS_descriptor_, &GPS::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Motion_descriptor_, &Motion::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Line_descriptor_, &Line::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Object_descriptor_, &Object::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    HMW_descriptor_, &HMW::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FCW_descriptor_, &FCW::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PCW_descriptor_, &PCW::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LDW_descriptor_, &LDW::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    WarningResult_descriptor_, &WarningResult::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    AdasOutput_descriptor_, &AdasOutput::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_adas_5foutput_2eproto() {
  delete GroundPoint::default_instance_;
  delete GroundPoint_reflection_;
  delete Rect::default_instance_;
  delete Rect_reflection_;
  delete CameraInfo::default_instance_;
  delete CameraInfo_reflection_;
  delete ImageFrame::default_instance_;
  delete ImageFrame_reflection_;
  delete GPS::default_instance_;
  delete GPS_reflection_;
  delete Motion::default_instance_;
  delete Motion_reflection_;
  delete Line::default_instance_;
  delete Line_reflection_;
  delete Object::default_instance_;
  delete Object_reflection_;
  delete HMW::default_instance_;
  delete HMW_reflection_;
  delete FCW::default_instance_;
  delete FCW_reflection_;
  delete PCW::default_instance_;
  delete PCW_reflection_;
  delete LDW::default_instance_;
  delete LDW_reflection_;
  delete WarningResult::default_instance_;
  delete WarningResult_reflection_;
  delete AdasOutput::default_instance_;
  delete AdasOutput_reflection_;
}

void protobuf_AddDesc_adas_5foutput_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\021adas_output.proto\022\022AdasOutputProtocol\""
    "#\n\013GroundPoint\022\t\n\001x\030\001 \002(\002\022\t\n\001z\030\002 \002(\002\"@\n\004"
    "Rect\022\014\n\004left\030\001 \002(\002\022\013\n\003top\030\002 \002(\002\022\r\n\005right"
    "\030\003 \002(\002\022\016\n\006bottom\030\004 \002(\002\"\'\n\nCameraInfo\022\n\n\002"
    "M_\030\001 \003(\002\022\r\n\005MInv_\030\002 \003(\002\"s\n\nImageFrame\022\r\n"
    "\005width\030\001 \002(\005\022\016\n\006height\030\002 \002(\005\022\022\n\ntime_sta"
    "mp\030\003 \002(\003\022\017\n\007channel\030\004 \001(\005\022\021\n\tsend_mode\030\005"
    " \001(\005\022\016\n\006format\030\006 \001(\005\"b\n\003GPS\022\022\n\ntime_stam"
    "p\030\001 \002(\003\022\021\n\tlongitude\030\002 \002(\001\022\020\n\010latitude\030\003"
    " \002(\001\022\020\n\010altitude\030\004 \001(\002\022\020\n\010gps_time\030\005 \001(\003"
    "\"M\n\006Motion\022\022\n\ntime_stamp\030\001 \002(\003\022\020\n\010veloci"
    "ty\030\002 \001(\002\022\020\n\010yaw_rate\030\003 \001(\002\022\013\n\003acc\030\004 \001(\002\""
    "\317\001\n\004Line\022\n\n\002id\030\001 \002(\005\022\014\n\004type\030\002 \001(\005\022\022\n\nti"
    "me_stamp\030\003 \001(\003\022\016\n\006coeffs\030\004 \003(\002\0223\n\nend_po"
    "ints\030\005 \003(\0132\037.AdasOutputProtocol.GroundPo"
    "int\022\033\n\023line_cross_distance\030\006 \001(\002\022\014\n\004ttlc"
    "\030\007 \001(\002\022\022\n\ndepature_v\030\010 \001(\002\022\025\n\rtracking_t"
    "ime\030\t \001(\003\"\221\002\n\006Object\022\n\n\002id\030\001 \002(\005\022\014\n\004type"
    "\030\002 \001(\005\022\022\n\ntime_stamp\030\003 \001(\003\022:\n\021relative_l"
    "ocation\030\004 \001(\0132\037.AdasOutputProtocol.Groun"
    "dPoint\022:\n\021relative_velocity\030\005 \001(\0132\037.Adas"
    "OutputProtocol.GroundPoint\022\013\n\003ttc\030\006 \001(\002\022"
    "&\n\004rect\030\007 \001(\0132\030.AdasOutputProtocol.Rect\022"
    "\025\n\rtracking_time\030\010 \001(\003\022\025\n\ris_key_object\030"
    "\t \001(\010\"\211\002\n\003HMW\022\027\n\017function_status\030\001 \001(\005\022\025"
    "\n\rwarning_level\030\002 \001(\005\022\032\n\022time_to_conllis"
    "ion\030\003 \001(\002\022\023\n\013object_type\030\004 \001(\005\022\016\n\006veh_id"
    "\030\005 \001(\005\"\220\001\n\010HmwLevel\022\022\n\016kHmwLevel_None\020\000\022"
    "\032\n\026kHmwLevel_NoticeLevel1\020\001\022\032\n\026kHmwLevel"
    "_NoticeLevel2\020\002\022\033\n\027kHmwLevel_WarningLeve"
    "l1\020\013\022\033\n\027kHmwLevel_WarningLevel2\020\014\"\255\001\n\003FC"
    "W\022\027\n\017function_status\030\001 \001(\005\022\025\n\rwarning_le"
    "vel\030\002 \001(\005\022\032\n\022time_to_conllision\030\003 \001(\002\022\023\n"
    "\013object_type\030\004 \001(\005\022\016\n\006veh_id\030\005 \001(\005\"5\n\010Fc"
    "wLevel\022\022\n\016kFcwLevel_None\020\000\022\025\n\021kFcwLevel_"
    "Warning\020\001\"\255\001\n\003PCW\022\027\n\017function_status\030\001 \001"
    "(\005\022\025\n\rwarning_level\030\002 \001(\005\022\032\n\022time_to_con"
    "llision\030\003 \001(\002\022\023\n\013object_type\030\004 \001(\005\022\016\n\006pe"
    "d_id\030\005 \001(\005\"5\n\010PcwLevel\022\022\n\016kPcwLevel_None"
    "\020\000\022\025\n\021kPcwLevel_Warning\020\001\"\327\001\n\003LDW\022\027\n\017fun"
    "ction_status\030\001 \001(\005\022\025\n\rwarning_level\030\002 \001("
    "\005\022\033\n\023line_cross_distance\030\003 \001(\002\022\023\n\013object"
    "_type\030\004 \001(\005\022\017\n\007line_id\030\005 \001(\005\"]\n\010LdwLevel"
    "\022\022\n\016kLdwLevel_None\020\000\022\035\n\031kLdwLevel_Warnin"
    "gLeftSide\020\001\022\036\n\032kLdwLevel_WarningRightSid"
    "e\020\002\"\275\001\n\rWarningResult\022$\n\003hmw\030\001 \001(\0132\027.Ada"
    "sOutputProtocol.HMW\022$\n\003fcw\030\002 \001(\0132\027.AdasO"
    "utputProtocol.FCW\022$\n\003ldw\030\003 \001(\0132\027.AdasOut"
    "putProtocol.LDW\022$\n\003pcw\030\004 \001(\0132\027.AdasOutpu"
    "tProtocol.PCW\022\024\n\014warning_type\030\005 \001(\005\"\243\003\n\n"
    "AdasOutput\022\017\n\007version\030\001 \002(\005\022\020\n\010frame_id\030"
    "\002 \002(\005\022.\n\006camera\030\003 \001(\0132\036.AdasOutputProtoc"
    "ol.CameraInfo\022-\n\005image\030\004 \001(\0132\036.AdasOutpu"
    "tProtocol.ImageFrame\022$\n\003gps\030\005 \001(\0132\027.Adas"
    "OutputProtocol.GPS\022*\n\006motion\030\006 \001(\0132\032.Ada"
    "sOutputProtocol.Motion\022,\n\010vehicles\030\007 \003(\013"
    "2\032.AdasOutputProtocol.Object\022/\n\013pedestri"
    "ans\030\010 \003(\0132\032.AdasOutputProtocol.Object\022\'\n"
    "\005lines\030\t \003(\0132\030.AdasOutputProtocol.Line\0229"
    "\n\016warning_result\030\n \001(\0132!.AdasOutputProto"
    "col.WarningResult*3\n\013ImageFormat\022\010\n\004GRAY"
    "\020\000\022\007\n\003YUV\020\001\022\010\n\004JPEG\020\002\022\007\n\003PNG\020\003*\202\001\n\010LineT"
    "ype\022\014\n\010LINE_RAW\020\000\022\r\n\tLINE_LEFT\020\001\022\016\n\nLINE"
    "_RIGHT\020\002\022\022\n\016LINE_LEFT_LEFT\020\004\022\024\n\020LINE_RIG"
    "HT_RIGHT\020\010\022\016\n\tLINE_DASH\020\200\010\022\017\n\nLINE_SOLID"
    "\020\200\020*b\n\016FunctionStatus\022\023\n\017kStatus_Disable"
    "\020\000\022\022\n\016kStatus_Enable\020\001\022\023\n\017kStatus_Inhibi"
    "t\020\002\022\022\n\016kStatus_Failed\020\003*\250\001\n\014WarningLevel"
    "\022\026\n\022kWarningLevel_None\020\000\022\036\n\032kWarningLeve"
    "l_NoticeLevel1\020\001\022\036\n\032kWarningLevel_Notice"
    "Level2\020\002\022\037\n\033kWarningLevel_WarningLevel1\020"
    "\003\022\037\n\033kWarningLevel_WarningLevel2\020\004*i\n\013Wa"
    "rningType\022\025\n\021kWarningLevel_Hmw\020\000\022\025\n\021kWar"
    "ningLevel_Fcw\020\001\022\025\n\021kWarningLevel_Pcw\020\002\022\025"
    "\n\021kWarningLevel_Ldw\020\003", 2981);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "adas_output.proto", &protobuf_RegisterTypes);
  GroundPoint::default_instance_ = new GroundPoint();
  Rect::default_instance_ = new Rect();
  CameraInfo::default_instance_ = new CameraInfo();
  ImageFrame::default_instance_ = new ImageFrame();
  GPS::default_instance_ = new GPS();
  Motion::default_instance_ = new Motion();
  Line::default_instance_ = new Line();
  Object::default_instance_ = new Object();
  HMW::default_instance_ = new HMW();
  FCW::default_instance_ = new FCW();
  PCW::default_instance_ = new PCW();
  LDW::default_instance_ = new LDW();
  WarningResult::default_instance_ = new WarningResult();
  AdasOutput::default_instance_ = new AdasOutput();
  GroundPoint::default_instance_->InitAsDefaultInstance();
  Rect::default_instance_->InitAsDefaultInstance();
  CameraInfo::default_instance_->InitAsDefaultInstance();
  ImageFrame::default_instance_->InitAsDefaultInstance();
  GPS::default_instance_->InitAsDefaultInstance();
  Motion::default_instance_->InitAsDefaultInstance();
  Line::default_instance_->InitAsDefaultInstance();
  Object::default_instance_->InitAsDefaultInstance();
  HMW::default_instance_->InitAsDefaultInstance();
  FCW::default_instance_->InitAsDefaultInstance();
  PCW::default_instance_->InitAsDefaultInstance();
  LDW::default_instance_->InitAsDefaultInstance();
  WarningResult::default_instance_->InitAsDefaultInstance();
  AdasOutput::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_adas_5foutput_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_adas_5foutput_2eproto {
  StaticDescriptorInitializer_adas_5foutput_2eproto() {
    protobuf_AddDesc_adas_5foutput_2eproto();
  }
} static_descriptor_initializer_adas_5foutput_2eproto_;
const ::google::protobuf::EnumDescriptor* ImageFormat_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ImageFormat_descriptor_;
}
bool ImageFormat_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* LineType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LineType_descriptor_;
}
bool LineType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 4:
    case 8:
    case 1024:
    case 2048:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* FunctionStatus_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FunctionStatus_descriptor_;
}
bool FunctionStatus_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* WarningLevel_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WarningLevel_descriptor_;
}
bool WarningLevel_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* WarningType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WarningType_descriptor_;
}
bool WarningType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int GroundPoint::kXFieldNumber;
const int GroundPoint::kZFieldNumber;
#endif  // !_MSC_VER

GroundPoint::GroundPoint()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AdasOutputProtocol.GroundPoint)
}

void GroundPoint::InitAsDefaultInstance() {
}

GroundPoint::GroundPoint(const GroundPoint& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:AdasOutputProtocol.GroundPoint)
}

void GroundPoint::SharedCtor() {
  _cached_size_ = 0;
  x_ = 0;
  z_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GroundPoint::~GroundPoint() {
  // @@protoc_insertion_point(destructor:AdasOutputProtocol.GroundPoint)
  SharedDtor();
}

void GroundPoint::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GroundPoint::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GroundPoint::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GroundPoint_descriptor_;
}

const GroundPoint& GroundPoint::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_adas_5foutput_2eproto();
  return *default_instance_;
}

GroundPoint* GroundPoint::default_instance_ = NULL;

GroundPoint* GroundPoint::New() const {
  return new GroundPoint;
}

void GroundPoint::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GroundPoint*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(x_, z_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GroundPoint::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:AdasOutputProtocol.GroundPoint)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float x = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &x_)));
          set_has_x();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_z;
        break;
      }

      // required float z = 2;
      case 2: {
        if (tag == 21) {
         parse_z:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &z_)));
          set_has_z();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:AdasOutputProtocol.GroundPoint)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:AdasOutputProtocol.GroundPoint)
  return false;
#undef DO_
}

void GroundPoint::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:AdasOutputProtocol.GroundPoint)
  // required float x = 1;
  if (has_x()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->x(), output);
  }

  // required float z = 2;
  if (has_z()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->z(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:AdasOutputProtocol.GroundPoint)
}

::google::protobuf::uint8* GroundPoint::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:AdasOutputProtocol.GroundPoint)
  // required float x = 1;
  if (has_x()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->x(), target);
  }

  // required float z = 2;
  if (has_z()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->z(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AdasOutputProtocol.GroundPoint)
  return target;
}

int GroundPoint::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float x = 1;
    if (has_x()) {
      total_size += 1 + 4;
    }

    // required float z = 2;
    if (has_z()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GroundPoint::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GroundPoint* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GroundPoint*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GroundPoint::MergeFrom(const GroundPoint& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x()) {
      set_x(from.x());
    }
    if (from.has_z()) {
      set_z(from.z());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GroundPoint::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GroundPoint::CopyFrom(const GroundPoint& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GroundPoint::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void GroundPoint::Swap(GroundPoint* other) {
  if (other != this) {
    std::swap(x_, other->x_);
    std::swap(z_, other->z_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GroundPoint::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GroundPoint_descriptor_;
  metadata.reflection = GroundPoint_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Rect::kLeftFieldNumber;
const int Rect::kTopFieldNumber;
const int Rect::kRightFieldNumber;
const int Rect::kBottomFieldNumber;
#endif  // !_MSC_VER

Rect::Rect()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AdasOutputProtocol.Rect)
}

void Rect::InitAsDefaultInstance() {
}

Rect::Rect(const Rect& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:AdasOutputProtocol.Rect)
}

void Rect::SharedCtor() {
  _cached_size_ = 0;
  left_ = 0;
  top_ = 0;
  right_ = 0;
  bottom_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Rect::~Rect() {
  // @@protoc_insertion_point(destructor:AdasOutputProtocol.Rect)
  SharedDtor();
}

void Rect::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Rect::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Rect::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Rect_descriptor_;
}

const Rect& Rect::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_adas_5foutput_2eproto();
  return *default_instance_;
}

Rect* Rect::default_instance_ = NULL;

Rect* Rect::New() const {
  return new Rect;
}

void Rect::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Rect*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(left_, bottom_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Rect::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:AdasOutputProtocol.Rect)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required float left = 1;
      case 1: {
        if (tag == 13) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &left_)));
          set_has_left();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_top;
        break;
      }

      // required float top = 2;
      case 2: {
        if (tag == 21) {
         parse_top:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &top_)));
          set_has_top();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_right;
        break;
      }

      // required float right = 3;
      case 3: {
        if (tag == 29) {
         parse_right:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &right_)));
          set_has_right();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_bottom;
        break;
      }

      // required float bottom = 4;
      case 4: {
        if (tag == 37) {
         parse_bottom:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &bottom_)));
          set_has_bottom();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:AdasOutputProtocol.Rect)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:AdasOutputProtocol.Rect)
  return false;
#undef DO_
}

void Rect::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:AdasOutputProtocol.Rect)
  // required float left = 1;
  if (has_left()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->left(), output);
  }

  // required float top = 2;
  if (has_top()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->top(), output);
  }

  // required float right = 3;
  if (has_right()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->right(), output);
  }

  // required float bottom = 4;
  if (has_bottom()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->bottom(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:AdasOutputProtocol.Rect)
}

::google::protobuf::uint8* Rect::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:AdasOutputProtocol.Rect)
  // required float left = 1;
  if (has_left()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->left(), target);
  }

  // required float top = 2;
  if (has_top()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->top(), target);
  }

  // required float right = 3;
  if (has_right()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->right(), target);
  }

  // required float bottom = 4;
  if (has_bottom()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->bottom(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AdasOutputProtocol.Rect)
  return target;
}

int Rect::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required float left = 1;
    if (has_left()) {
      total_size += 1 + 4;
    }

    // required float top = 2;
    if (has_top()) {
      total_size += 1 + 4;
    }

    // required float right = 3;
    if (has_right()) {
      total_size += 1 + 4;
    }

    // required float bottom = 4;
    if (has_bottom()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Rect::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Rect* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Rect*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Rect::MergeFrom(const Rect& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_left()) {
      set_left(from.left());
    }
    if (from.has_top()) {
      set_top(from.top());
    }
    if (from.has_right()) {
      set_right(from.right());
    }
    if (from.has_bottom()) {
      set_bottom(from.bottom());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Rect::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Rect::CopyFrom(const Rect& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Rect::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  return true;
}

void Rect::Swap(Rect* other) {
  if (other != this) {
    std::swap(left_, other->left_);
    std::swap(top_, other->top_);
    std::swap(right_, other->right_);
    std::swap(bottom_, other->bottom_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Rect::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Rect_descriptor_;
  metadata.reflection = Rect_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CameraInfo::kMFieldNumber;
const int CameraInfo::kMInvFieldNumber;
#endif  // !_MSC_VER

CameraInfo::CameraInfo()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AdasOutputProtocol.CameraInfo)
}

void CameraInfo::InitAsDefaultInstance() {
}

CameraInfo::CameraInfo(const CameraInfo& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:AdasOutputProtocol.CameraInfo)
}

void CameraInfo::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CameraInfo::~CameraInfo() {
  // @@protoc_insertion_point(destructor:AdasOutputProtocol.CameraInfo)
  SharedDtor();
}

void CameraInfo::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CameraInfo::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CameraInfo::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CameraInfo_descriptor_;
}

const CameraInfo& CameraInfo::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_adas_5foutput_2eproto();
  return *default_instance_;
}

CameraInfo* CameraInfo::default_instance_ = NULL;

CameraInfo* CameraInfo::New() const {
  return new CameraInfo;
}

void CameraInfo::Clear() {
  m__.Clear();
  minv__.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CameraInfo::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:AdasOutputProtocol.CameraInfo)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated float M_ = 1;
      case 1: {
        if (tag == 13) {
         parse_M_:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 13, input, this->mutable_m_())));
        } else if (tag == 10) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_m_())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(13)) goto parse_M_;
        if (input->ExpectTag(21)) goto parse_MInv_;
        break;
      }

      // repeated float MInv_ = 2;
      case 2: {
        if (tag == 21) {
         parse_MInv_:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 21, input, this->mutable_minv_())));
        } else if (tag == 18) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_minv_())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_MInv_;
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:AdasOutputProtocol.CameraInfo)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:AdasOutputProtocol.CameraInfo)
  return false;
#undef DO_
}

void CameraInfo::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:AdasOutputProtocol.CameraInfo)
  // repeated float M_ = 1;
  for (int i = 0; i < this->m__size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      1, this->m_(i), output);
  }

  // repeated float MInv_ = 2;
  for (int i = 0; i < this->minv__size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      2, this->minv_(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:AdasOutputProtocol.CameraInfo)
}

::google::protobuf::uint8* CameraInfo::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:AdasOutputProtocol.CameraInfo)
  // repeated float M_ = 1;
  for (int i = 0; i < this->m__size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(1, this->m_(i), target);
  }

  // repeated float MInv_ = 2;
  for (int i = 0; i < this->minv__size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(2, this->minv_(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AdasOutputProtocol.CameraInfo)
  return target;
}

int CameraInfo::ByteSize() const {
  int total_size = 0;

  // repeated float M_ = 1;
  {
    int data_size = 0;
    data_size = 4 * this->m__size();
    total_size += 1 * this->m__size() + data_size;
  }

  // repeated float MInv_ = 2;
  {
    int data_size = 0;
    data_size = 4 * this->minv__size();
    total_size += 1 * this->minv__size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CameraInfo::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CameraInfo* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CameraInfo*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CameraInfo::MergeFrom(const CameraInfo& from) {
  GOOGLE_CHECK_NE(&from, this);
  m__.MergeFrom(from.m__);
  minv__.MergeFrom(from.minv__);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CameraInfo::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CameraInfo::CopyFrom(const CameraInfo& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CameraInfo::IsInitialized() const {

  return true;
}

void CameraInfo::Swap(CameraInfo* other) {
  if (other != this) {
    m__.Swap(&other->m__);
    minv__.Swap(&other->minv__);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CameraInfo::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CameraInfo_descriptor_;
  metadata.reflection = CameraInfo_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ImageFrame::kWidthFieldNumber;
const int ImageFrame::kHeightFieldNumber;
const int ImageFrame::kTimeStampFieldNumber;
const int ImageFrame::kChannelFieldNumber;
const int ImageFrame::kSendModeFieldNumber;
const int ImageFrame::kFormatFieldNumber;
#endif  // !_MSC_VER

ImageFrame::ImageFrame()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AdasOutputProtocol.ImageFrame)
}

void ImageFrame::InitAsDefaultInstance() {
}

ImageFrame::ImageFrame(const ImageFrame& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:AdasOutputProtocol.ImageFrame)
}

void ImageFrame::SharedCtor() {
  _cached_size_ = 0;
  width_ = 0;
  height_ = 0;
  time_stamp_ = GOOGLE_LONGLONG(0);
  channel_ = 0;
  send_mode_ = 0;
  format_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ImageFrame::~ImageFrame() {
  // @@protoc_insertion_point(destructor:AdasOutputProtocol.ImageFrame)
  SharedDtor();
}

void ImageFrame::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ImageFrame::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ImageFrame::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ImageFrame_descriptor_;
}

const ImageFrame& ImageFrame::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_adas_5foutput_2eproto();
  return *default_instance_;
}

ImageFrame* ImageFrame::default_instance_ = NULL;

ImageFrame* ImageFrame::New() const {
  return new ImageFrame;
}

void ImageFrame::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<ImageFrame*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(width_, format_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ImageFrame::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:AdasOutputProtocol.ImageFrame)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 width = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_height;
        break;
      }

      // required int32 height = 2;
      case 2: {
        if (tag == 16) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_time_stamp;
        break;
      }

      // required int64 time_stamp = 3;
      case 3: {
        if (tag == 24) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_channel;
        break;
      }

      // optional int32 channel = 4;
      case 4: {
        if (tag == 32) {
         parse_channel:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &channel_)));
          set_has_channel();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_send_mode;
        break;
      }

      // optional int32 send_mode = 5;
      case 5: {
        if (tag == 40) {
         parse_send_mode:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &send_mode_)));
          set_has_send_mode();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(48)) goto parse_format;
        break;
      }

      // optional int32 format = 6;
      case 6: {
        if (tag == 48) {
         parse_format:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &format_)));
          set_has_format();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:AdasOutputProtocol.ImageFrame)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:AdasOutputProtocol.ImageFrame)
  return false;
#undef DO_
}

void ImageFrame::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:AdasOutputProtocol.ImageFrame)
  // required int32 width = 1;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->width(), output);
  }

  // required int32 height = 2;
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->height(), output);
  }

  // required int64 time_stamp = 3;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->time_stamp(), output);
  }

  // optional int32 channel = 4;
  if (has_channel()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->channel(), output);
  }

  // optional int32 send_mode = 5;
  if (has_send_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->send_mode(), output);
  }

  // optional int32 format = 6;
  if (has_format()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(6, this->format(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:AdasOutputProtocol.ImageFrame)
}

::google::protobuf::uint8* ImageFrame::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:AdasOutputProtocol.ImageFrame)
  // required int32 width = 1;
  if (has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->width(), target);
  }

  // required int32 height = 2;
  if (has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->height(), target);
  }

  // required int64 time_stamp = 3;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->time_stamp(), target);
  }

  // optional int32 channel = 4;
  if (has_channel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->channel(), target);
  }

  // optional int32 send_mode = 5;
  if (has_send_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->send_mode(), target);
  }

  // optional int32 format = 6;
  if (has_format()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(6, this->format(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AdasOutputProtocol.ImageFrame)
  return target;
}

int ImageFrame::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 width = 1;
    if (has_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->width());
    }

    // required int32 height = 2;
    if (has_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->height());
    }

    // required int64 time_stamp = 3;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->time_stamp());
    }

    // optional int32 channel = 4;
    if (has_channel()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->channel());
    }

    // optional int32 send_mode = 5;
    if (has_send_mode()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->send_mode());
    }

    // optional int32 format = 6;
    if (has_format()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->format());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ImageFrame::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ImageFrame* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ImageFrame*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ImageFrame::MergeFrom(const ImageFrame& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_channel()) {
      set_channel(from.channel());
    }
    if (from.has_send_mode()) {
      set_send_mode(from.send_mode());
    }
    if (from.has_format()) {
      set_format(from.format());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ImageFrame::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ImageFrame::CopyFrom(const ImageFrame& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ImageFrame::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void ImageFrame::Swap(ImageFrame* other) {
  if (other != this) {
    std::swap(width_, other->width_);
    std::swap(height_, other->height_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(channel_, other->channel_);
    std::swap(send_mode_, other->send_mode_);
    std::swap(format_, other->format_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ImageFrame::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ImageFrame_descriptor_;
  metadata.reflection = ImageFrame_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int GPS::kTimeStampFieldNumber;
const int GPS::kLongitudeFieldNumber;
const int GPS::kLatitudeFieldNumber;
const int GPS::kAltitudeFieldNumber;
const int GPS::kGpsTimeFieldNumber;
#endif  // !_MSC_VER

GPS::GPS()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AdasOutputProtocol.GPS)
}

void GPS::InitAsDefaultInstance() {
}

GPS::GPS(const GPS& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:AdasOutputProtocol.GPS)
}

void GPS::SharedCtor() {
  _cached_size_ = 0;
  time_stamp_ = GOOGLE_LONGLONG(0);
  longitude_ = 0;
  latitude_ = 0;
  altitude_ = 0;
  gps_time_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

GPS::~GPS() {
  // @@protoc_insertion_point(destructor:AdasOutputProtocol.GPS)
  SharedDtor();
}

void GPS::SharedDtor() {
  if (this != default_instance_) {
  }
}

void GPS::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* GPS::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return GPS_descriptor_;
}

const GPS& GPS::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_adas_5foutput_2eproto();
  return *default_instance_;
}

GPS* GPS::default_instance_ = NULL;

GPS* GPS::New() const {
  return new GPS;
}

void GPS::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<GPS*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(time_stamp_, altitude_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool GPS::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:AdasOutputProtocol.GPS)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 time_stamp = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(17)) goto parse_longitude;
        break;
      }

      // required double longitude = 2;
      case 2: {
        if (tag == 17) {
         parse_longitude:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &longitude_)));
          set_has_longitude();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(25)) goto parse_latitude;
        break;
      }

      // required double latitude = 3;
      case 3: {
        if (tag == 25) {
         parse_latitude:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &latitude_)));
          set_has_latitude();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_altitude;
        break;
      }

      // optional float altitude = 4;
      case 4: {
        if (tag == 37) {
         parse_altitude:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &altitude_)));
          set_has_altitude();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_gps_time;
        break;
      }

      // optional int64 gps_time = 5;
      case 5: {
        if (tag == 40) {
         parse_gps_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &gps_time_)));
          set_has_gps_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:AdasOutputProtocol.GPS)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:AdasOutputProtocol.GPS)
  return false;
#undef DO_
}

void GPS::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:AdasOutputProtocol.GPS)
  // required int64 time_stamp = 1;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->time_stamp(), output);
  }

  // required double longitude = 2;
  if (has_longitude()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->longitude(), output);
  }

  // required double latitude = 3;
  if (has_latitude()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->latitude(), output);
  }

  // optional float altitude = 4;
  if (has_altitude()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->altitude(), output);
  }

  // optional int64 gps_time = 5;
  if (has_gps_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(5, this->gps_time(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:AdasOutputProtocol.GPS)
}

::google::protobuf::uint8* GPS::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:AdasOutputProtocol.GPS)
  // required int64 time_stamp = 1;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->time_stamp(), target);
  }

  // required double longitude = 2;
  if (has_longitude()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->longitude(), target);
  }

  // required double latitude = 3;
  if (has_latitude()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->latitude(), target);
  }

  // optional float altitude = 4;
  if (has_altitude()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->altitude(), target);
  }

  // optional int64 gps_time = 5;
  if (has_gps_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(5, this->gps_time(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AdasOutputProtocol.GPS)
  return target;
}

int GPS::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 time_stamp = 1;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->time_stamp());
    }

    // required double longitude = 2;
    if (has_longitude()) {
      total_size += 1 + 8;
    }

    // required double latitude = 3;
    if (has_latitude()) {
      total_size += 1 + 8;
    }

    // optional float altitude = 4;
    if (has_altitude()) {
      total_size += 1 + 4;
    }

    // optional int64 gps_time = 5;
    if (has_gps_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->gps_time());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void GPS::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const GPS* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const GPS*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void GPS::MergeFrom(const GPS& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_longitude()) {
      set_longitude(from.longitude());
    }
    if (from.has_latitude()) {
      set_latitude(from.latitude());
    }
    if (from.has_altitude()) {
      set_altitude(from.altitude());
    }
    if (from.has_gps_time()) {
      set_gps_time(from.gps_time());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void GPS::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void GPS::CopyFrom(const GPS& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool GPS::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void GPS::Swap(GPS* other) {
  if (other != this) {
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(longitude_, other->longitude_);
    std::swap(latitude_, other->latitude_);
    std::swap(altitude_, other->altitude_);
    std::swap(gps_time_, other->gps_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata GPS::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = GPS_descriptor_;
  metadata.reflection = GPS_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Motion::kTimeStampFieldNumber;
const int Motion::kVelocityFieldNumber;
const int Motion::kYawRateFieldNumber;
const int Motion::kAccFieldNumber;
#endif  // !_MSC_VER

Motion::Motion()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AdasOutputProtocol.Motion)
}

void Motion::InitAsDefaultInstance() {
}

Motion::Motion(const Motion& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:AdasOutputProtocol.Motion)
}

void Motion::SharedCtor() {
  _cached_size_ = 0;
  time_stamp_ = GOOGLE_LONGLONG(0);
  velocity_ = 0;
  yaw_rate_ = 0;
  acc_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Motion::~Motion() {
  // @@protoc_insertion_point(destructor:AdasOutputProtocol.Motion)
  SharedDtor();
}

void Motion::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Motion::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Motion::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Motion_descriptor_;
}

const Motion& Motion::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_adas_5foutput_2eproto();
  return *default_instance_;
}

Motion* Motion::default_instance_ = NULL;

Motion* Motion::New() const {
  return new Motion;
}

void Motion::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Motion*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  ZR_(time_stamp_, acc_);

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Motion::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:AdasOutputProtocol.Motion)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int64 time_stamp = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(21)) goto parse_velocity;
        break;
      }

      // optional float velocity = 2;
      case 2: {
        if (tag == 21) {
         parse_velocity:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &velocity_)));
          set_has_velocity();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_yaw_rate;
        break;
      }

      // optional float yaw_rate = 3;
      case 3: {
        if (tag == 29) {
         parse_yaw_rate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &yaw_rate_)));
          set_has_yaw_rate();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_acc;
        break;
      }

      // optional float acc = 4;
      case 4: {
        if (tag == 37) {
         parse_acc:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &acc_)));
          set_has_acc();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:AdasOutputProtocol.Motion)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:AdasOutputProtocol.Motion)
  return false;
#undef DO_
}

void Motion::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:AdasOutputProtocol.Motion)
  // required int64 time_stamp = 1;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(1, this->time_stamp(), output);
  }

  // optional float velocity = 2;
  if (has_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(2, this->velocity(), output);
  }

  // optional float yaw_rate = 3;
  if (has_yaw_rate()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->yaw_rate(), output);
  }

  // optional float acc = 4;
  if (has_acc()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(4, this->acc(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:AdasOutputProtocol.Motion)
}

::google::protobuf::uint8* Motion::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:AdasOutputProtocol.Motion)
  // required int64 time_stamp = 1;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(1, this->time_stamp(), target);
  }

  // optional float velocity = 2;
  if (has_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(2, this->velocity(), target);
  }

  // optional float yaw_rate = 3;
  if (has_yaw_rate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->yaw_rate(), target);
  }

  // optional float acc = 4;
  if (has_acc()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(4, this->acc(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AdasOutputProtocol.Motion)
  return target;
}

int Motion::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int64 time_stamp = 1;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->time_stamp());
    }

    // optional float velocity = 2;
    if (has_velocity()) {
      total_size += 1 + 4;
    }

    // optional float yaw_rate = 3;
    if (has_yaw_rate()) {
      total_size += 1 + 4;
    }

    // optional float acc = 4;
    if (has_acc()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Motion::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Motion* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Motion*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Motion::MergeFrom(const Motion& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_velocity()) {
      set_velocity(from.velocity());
    }
    if (from.has_yaw_rate()) {
      set_yaw_rate(from.yaw_rate());
    }
    if (from.has_acc()) {
      set_acc(from.acc());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Motion::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Motion::CopyFrom(const Motion& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Motion::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void Motion::Swap(Motion* other) {
  if (other != this) {
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(velocity_, other->velocity_);
    std::swap(yaw_rate_, other->yaw_rate_);
    std::swap(acc_, other->acc_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Motion::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Motion_descriptor_;
  metadata.reflection = Motion_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Line::kIdFieldNumber;
const int Line::kTypeFieldNumber;
const int Line::kTimeStampFieldNumber;
const int Line::kCoeffsFieldNumber;
const int Line::kEndPointsFieldNumber;
const int Line::kLineCrossDistanceFieldNumber;
const int Line::kTtlcFieldNumber;
const int Line::kDepatureVFieldNumber;
const int Line::kTrackingTimeFieldNumber;
#endif  // !_MSC_VER

Line::Line()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AdasOutputProtocol.Line)
}

void Line::InitAsDefaultInstance() {
}

Line::Line(const Line& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:AdasOutputProtocol.Line)
}

void Line::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  type_ = 0;
  time_stamp_ = GOOGLE_LONGLONG(0);
  line_cross_distance_ = 0;
  ttlc_ = 0;
  depature_v_ = 0;
  tracking_time_ = GOOGLE_LONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Line::~Line() {
  // @@protoc_insertion_point(destructor:AdasOutputProtocol.Line)
  SharedDtor();
}

void Line::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Line::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Line::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Line_descriptor_;
}

const Line& Line::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_adas_5foutput_2eproto();
  return *default_instance_;
}

Line* Line::default_instance_ = NULL;

Line* Line::New() const {
  return new Line;
}

void Line::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Line*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 231) {
    ZR_(id_, time_stamp_);
    ZR_(line_cross_distance_, ttlc_);
    depature_v_ = 0;
  }
  tracking_time_ = GOOGLE_LONGLONG(0);

#undef OFFSET_OF_FIELD_
#undef ZR_

  coeffs_.Clear();
  end_points_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Line::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:AdasOutputProtocol.Line)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // optional int32 type = 2;
      case 2: {
        if (tag == 16) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_time_stamp;
        break;
      }

      // optional int64 time_stamp = 3;
      case 3: {
        if (tag == 24) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_coeffs;
        break;
      }

      // repeated float coeffs = 4;
      case 4: {
        if (tag == 37) {
         parse_coeffs:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 1, 37, input, this->mutable_coeffs())));
        } else if (tag == 34) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, this->mutable_coeffs())));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(37)) goto parse_coeffs;
        if (input->ExpectTag(42)) goto parse_end_points;
        break;
      }

      // repeated .AdasOutputProtocol.GroundPoint end_points = 5;
      case 5: {
        if (tag == 42) {
         parse_end_points:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_end_points()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_end_points;
        if (input->ExpectTag(53)) goto parse_line_cross_distance;
        break;
      }

      // optional float line_cross_distance = 6;
      case 6: {
        if (tag == 53) {
         parse_line_cross_distance:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &line_cross_distance_)));
          set_has_line_cross_distance();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(61)) goto parse_ttlc;
        break;
      }

      // optional float ttlc = 7;
      case 7: {
        if (tag == 61) {
         parse_ttlc:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &ttlc_)));
          set_has_ttlc();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(69)) goto parse_depature_v;
        break;
      }

      // optional float depature_v = 8;
      case 8: {
        if (tag == 69) {
         parse_depature_v:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &depature_v_)));
          set_has_depature_v();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_tracking_time;
        break;
      }

      // optional int64 tracking_time = 9;
      case 9: {
        if (tag == 72) {
         parse_tracking_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &tracking_time_)));
          set_has_tracking_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:AdasOutputProtocol.Line)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:AdasOutputProtocol.Line)
  return false;
#undef DO_
}

void Line::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:AdasOutputProtocol.Line)
  // required int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional int32 type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->type(), output);
  }

  // optional int64 time_stamp = 3;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->time_stamp(), output);
  }

  // repeated float coeffs = 4;
  for (int i = 0; i < this->coeffs_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(
      4, this->coeffs(i), output);
  }

  // repeated .AdasOutputProtocol.GroundPoint end_points = 5;
  for (int i = 0; i < this->end_points_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->end_points(i), output);
  }

  // optional float line_cross_distance = 6;
  if (has_line_cross_distance()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->line_cross_distance(), output);
  }

  // optional float ttlc = 7;
  if (has_ttlc()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(7, this->ttlc(), output);
  }

  // optional float depature_v = 8;
  if (has_depature_v()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(8, this->depature_v(), output);
  }

  // optional int64 tracking_time = 9;
  if (has_tracking_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(9, this->tracking_time(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:AdasOutputProtocol.Line)
}

::google::protobuf::uint8* Line::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:AdasOutputProtocol.Line)
  // required int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // optional int32 type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->type(), target);
  }

  // optional int64 time_stamp = 3;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->time_stamp(), target);
  }

  // repeated float coeffs = 4;
  for (int i = 0; i < this->coeffs_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteFloatToArray(4, this->coeffs(i), target);
  }

  // repeated .AdasOutputProtocol.GroundPoint end_points = 5;
  for (int i = 0; i < this->end_points_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->end_points(i), target);
  }

  // optional float line_cross_distance = 6;
  if (has_line_cross_distance()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->line_cross_distance(), target);
  }

  // optional float ttlc = 7;
  if (has_ttlc()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(7, this->ttlc(), target);
  }

  // optional float depature_v = 8;
  if (has_depature_v()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(8, this->depature_v(), target);
  }

  // optional int64 tracking_time = 9;
  if (has_tracking_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(9, this->tracking_time(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AdasOutputProtocol.Line)
  return target;
}

int Line::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional int32 type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional int64 time_stamp = 3;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->time_stamp());
    }

    // optional float line_cross_distance = 6;
    if (has_line_cross_distance()) {
      total_size += 1 + 4;
    }

    // optional float ttlc = 7;
    if (has_ttlc()) {
      total_size += 1 + 4;
    }

    // optional float depature_v = 8;
    if (has_depature_v()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional int64 tracking_time = 9;
    if (has_tracking_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->tracking_time());
    }

  }
  // repeated float coeffs = 4;
  {
    int data_size = 0;
    data_size = 4 * this->coeffs_size();
    total_size += 1 * this->coeffs_size() + data_size;
  }

  // repeated .AdasOutputProtocol.GroundPoint end_points = 5;
  total_size += 1 * this->end_points_size();
  for (int i = 0; i < this->end_points_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->end_points(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Line::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Line* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Line*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Line::MergeFrom(const Line& from) {
  GOOGLE_CHECK_NE(&from, this);
  coeffs_.MergeFrom(from.coeffs_);
  end_points_.MergeFrom(from.end_points_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_line_cross_distance()) {
      set_line_cross_distance(from.line_cross_distance());
    }
    if (from.has_ttlc()) {
      set_ttlc(from.ttlc());
    }
    if (from.has_depature_v()) {
      set_depature_v(from.depature_v());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_tracking_time()) {
      set_tracking_time(from.tracking_time());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Line::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Line::CopyFrom(const Line& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Line::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (!::google::protobuf::internal::AllAreInitialized(this->end_points())) return false;
  return true;
}

void Line::Swap(Line* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(type_, other->type_);
    std::swap(time_stamp_, other->time_stamp_);
    coeffs_.Swap(&other->coeffs_);
    end_points_.Swap(&other->end_points_);
    std::swap(line_cross_distance_, other->line_cross_distance_);
    std::swap(ttlc_, other->ttlc_);
    std::swap(depature_v_, other->depature_v_);
    std::swap(tracking_time_, other->tracking_time_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Line::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Line_descriptor_;
  metadata.reflection = Line_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Object::kIdFieldNumber;
const int Object::kTypeFieldNumber;
const int Object::kTimeStampFieldNumber;
const int Object::kRelativeLocationFieldNumber;
const int Object::kRelativeVelocityFieldNumber;
const int Object::kTtcFieldNumber;
const int Object::kRectFieldNumber;
const int Object::kTrackingTimeFieldNumber;
const int Object::kIsKeyObjectFieldNumber;
#endif  // !_MSC_VER

Object::Object()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AdasOutputProtocol.Object)
}

void Object::InitAsDefaultInstance() {
  relative_location_ = const_cast< ::AdasOutputProtocol::GroundPoint*>(&::AdasOutputProtocol::GroundPoint::default_instance());
  relative_velocity_ = const_cast< ::AdasOutputProtocol::GroundPoint*>(&::AdasOutputProtocol::GroundPoint::default_instance());
  rect_ = const_cast< ::AdasOutputProtocol::Rect*>(&::AdasOutputProtocol::Rect::default_instance());
}

Object::Object(const Object& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:AdasOutputProtocol.Object)
}

void Object::SharedCtor() {
  _cached_size_ = 0;
  id_ = 0;
  type_ = 0;
  time_stamp_ = GOOGLE_LONGLONG(0);
  relative_location_ = NULL;
  relative_velocity_ = NULL;
  ttc_ = 0;
  rect_ = NULL;
  tracking_time_ = GOOGLE_LONGLONG(0);
  is_key_object_ = false;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Object::~Object() {
  // @@protoc_insertion_point(destructor:AdasOutputProtocol.Object)
  SharedDtor();
}

void Object::SharedDtor() {
  if (this != default_instance_) {
    delete relative_location_;
    delete relative_velocity_;
    delete rect_;
  }
}

void Object::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Object::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Object_descriptor_;
}

const Object& Object::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_adas_5foutput_2eproto();
  return *default_instance_;
}

Object* Object::default_instance_ = NULL;

Object* Object::New() const {
  return new Object;
}

void Object::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<Object*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 255) {
    ZR_(id_, time_stamp_);
    if (has_relative_location()) {
      if (relative_location_ != NULL) relative_location_->::AdasOutputProtocol::GroundPoint::Clear();
    }
    if (has_relative_velocity()) {
      if (relative_velocity_ != NULL) relative_velocity_->::AdasOutputProtocol::GroundPoint::Clear();
    }
    ttc_ = 0;
    if (has_rect()) {
      if (rect_ != NULL) rect_->::AdasOutputProtocol::Rect::Clear();
    }
    tracking_time_ = GOOGLE_LONGLONG(0);
  }
  is_key_object_ = false;

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Object::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:AdasOutputProtocol.Object)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 id = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
          set_has_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_type;
        break;
      }

      // optional int32 type = 2;
      case 2: {
        if (tag == 16) {
         parse_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &type_)));
          set_has_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(24)) goto parse_time_stamp;
        break;
      }

      // optional int64 time_stamp = 3;
      case 3: {
        if (tag == 24) {
         parse_time_stamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &time_stamp_)));
          set_has_time_stamp();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_relative_location;
        break;
      }

      // optional .AdasOutputProtocol.GroundPoint relative_location = 4;
      case 4: {
        if (tag == 34) {
         parse_relative_location:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_relative_location()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_relative_velocity;
        break;
      }

      // optional .AdasOutputProtocol.GroundPoint relative_velocity = 5;
      case 5: {
        if (tag == 42) {
         parse_relative_velocity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_relative_velocity()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(53)) goto parse_ttc;
        break;
      }

      // optional float ttc = 6;
      case 6: {
        if (tag == 53) {
         parse_ttc:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &ttc_)));
          set_has_ttc();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_rect;
        break;
      }

      // optional .AdasOutputProtocol.Rect rect = 7;
      case 7: {
        if (tag == 58) {
         parse_rect:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_rect()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(64)) goto parse_tracking_time;
        break;
      }

      // optional int64 tracking_time = 8;
      case 8: {
        if (tag == 64) {
         parse_tracking_time:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int64, ::google::protobuf::internal::WireFormatLite::TYPE_INT64>(
                 input, &tracking_time_)));
          set_has_tracking_time();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(72)) goto parse_is_key_object;
        break;
      }

      // optional bool is_key_object = 9;
      case 9: {
        if (tag == 72) {
         parse_is_key_object:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &is_key_object_)));
          set_has_is_key_object();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:AdasOutputProtocol.Object)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:AdasOutputProtocol.Object)
  return false;
#undef DO_
}

void Object::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:AdasOutputProtocol.Object)
  // required int32 id = 1;
  if (has_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional int32 type = 2;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->type(), output);
  }

  // optional int64 time_stamp = 3;
  if (has_time_stamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(3, this->time_stamp(), output);
  }

  // optional .AdasOutputProtocol.GroundPoint relative_location = 4;
  if (has_relative_location()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->relative_location(), output);
  }

  // optional .AdasOutputProtocol.GroundPoint relative_velocity = 5;
  if (has_relative_velocity()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->relative_velocity(), output);
  }

  // optional float ttc = 6;
  if (has_ttc()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(6, this->ttc(), output);
  }

  // optional .AdasOutputProtocol.Rect rect = 7;
  if (has_rect()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->rect(), output);
  }

  // optional int64 tracking_time = 8;
  if (has_tracking_time()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt64(8, this->tracking_time(), output);
  }

  // optional bool is_key_object = 9;
  if (has_is_key_object()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(9, this->is_key_object(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:AdasOutputProtocol.Object)
}

::google::protobuf::uint8* Object::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:AdasOutputProtocol.Object)
  // required int32 id = 1;
  if (has_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // optional int32 type = 2;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->type(), target);
  }

  // optional int64 time_stamp = 3;
  if (has_time_stamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(3, this->time_stamp(), target);
  }

  // optional .AdasOutputProtocol.GroundPoint relative_location = 4;
  if (has_relative_location()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->relative_location(), target);
  }

  // optional .AdasOutputProtocol.GroundPoint relative_velocity = 5;
  if (has_relative_velocity()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->relative_velocity(), target);
  }

  // optional float ttc = 6;
  if (has_ttc()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(6, this->ttc(), target);
  }

  // optional .AdasOutputProtocol.Rect rect = 7;
  if (has_rect()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->rect(), target);
  }

  // optional int64 tracking_time = 8;
  if (has_tracking_time()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt64ToArray(8, this->tracking_time(), target);
  }

  // optional bool is_key_object = 9;
  if (has_is_key_object()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(9, this->is_key_object(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AdasOutputProtocol.Object)
  return target;
}

int Object::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 id = 1;
    if (has_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->id());
    }

    // optional int32 type = 2;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->type());
    }

    // optional int64 time_stamp = 3;
    if (has_time_stamp()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->time_stamp());
    }

    // optional .AdasOutputProtocol.GroundPoint relative_location = 4;
    if (has_relative_location()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->relative_location());
    }

    // optional .AdasOutputProtocol.GroundPoint relative_velocity = 5;
    if (has_relative_velocity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->relative_velocity());
    }

    // optional float ttc = 6;
    if (has_ttc()) {
      total_size += 1 + 4;
    }

    // optional .AdasOutputProtocol.Rect rect = 7;
    if (has_rect()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->rect());
    }

    // optional int64 tracking_time = 8;
    if (has_tracking_time()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int64Size(
          this->tracking_time());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional bool is_key_object = 9;
    if (has_is_key_object()) {
      total_size += 1 + 1;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Object::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Object* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Object*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Object::MergeFrom(const Object& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_id()) {
      set_id(from.id());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_time_stamp()) {
      set_time_stamp(from.time_stamp());
    }
    if (from.has_relative_location()) {
      mutable_relative_location()->::AdasOutputProtocol::GroundPoint::MergeFrom(from.relative_location());
    }
    if (from.has_relative_velocity()) {
      mutable_relative_velocity()->::AdasOutputProtocol::GroundPoint::MergeFrom(from.relative_velocity());
    }
    if (from.has_ttc()) {
      set_ttc(from.ttc());
    }
    if (from.has_rect()) {
      mutable_rect()->::AdasOutputProtocol::Rect::MergeFrom(from.rect());
    }
    if (from.has_tracking_time()) {
      set_tracking_time(from.tracking_time());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_is_key_object()) {
      set_is_key_object(from.is_key_object());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Object::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Object::CopyFrom(const Object& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Object::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  if (has_relative_location()) {
    if (!this->relative_location().IsInitialized()) return false;
  }
  if (has_relative_velocity()) {
    if (!this->relative_velocity().IsInitialized()) return false;
  }
  if (has_rect()) {
    if (!this->rect().IsInitialized()) return false;
  }
  return true;
}

void Object::Swap(Object* other) {
  if (other != this) {
    std::swap(id_, other->id_);
    std::swap(type_, other->type_);
    std::swap(time_stamp_, other->time_stamp_);
    std::swap(relative_location_, other->relative_location_);
    std::swap(relative_velocity_, other->relative_velocity_);
    std::swap(ttc_, other->ttc_);
    std::swap(rect_, other->rect_);
    std::swap(tracking_time_, other->tracking_time_);
    std::swap(is_key_object_, other->is_key_object_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Object::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Object_descriptor_;
  metadata.reflection = Object_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* HMW_HmwLevel_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HMW_HmwLevel_descriptor_;
}
bool HMW_HmwLevel_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 11:
    case 12:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const HMW_HmwLevel HMW::kHmwLevel_None;
const HMW_HmwLevel HMW::kHmwLevel_NoticeLevel1;
const HMW_HmwLevel HMW::kHmwLevel_NoticeLevel2;
const HMW_HmwLevel HMW::kHmwLevel_WarningLevel1;
const HMW_HmwLevel HMW::kHmwLevel_WarningLevel2;
const HMW_HmwLevel HMW::HmwLevel_MIN;
const HMW_HmwLevel HMW::HmwLevel_MAX;
const int HMW::HmwLevel_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int HMW::kFunctionStatusFieldNumber;
const int HMW::kWarningLevelFieldNumber;
const int HMW::kTimeToConllisionFieldNumber;
const int HMW::kObjectTypeFieldNumber;
const int HMW::kVehIdFieldNumber;
#endif  // !_MSC_VER

HMW::HMW()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AdasOutputProtocol.HMW)
}

void HMW::InitAsDefaultInstance() {
}

HMW::HMW(const HMW& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:AdasOutputProtocol.HMW)
}

void HMW::SharedCtor() {
  _cached_size_ = 0;
  function_status_ = 0;
  warning_level_ = 0;
  time_to_conllision_ = 0;
  object_type_ = 0;
  veh_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

HMW::~HMW() {
  // @@protoc_insertion_point(destructor:AdasOutputProtocol.HMW)
  SharedDtor();
}

void HMW::SharedDtor() {
  if (this != default_instance_) {
  }
}

void HMW::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* HMW::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return HMW_descriptor_;
}

const HMW& HMW::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_adas_5foutput_2eproto();
  return *default_instance_;
}

HMW* HMW::default_instance_ = NULL;

HMW* HMW::New() const {
  return new HMW;
}

void HMW::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<HMW*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(function_status_, veh_id_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool HMW::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:AdasOutputProtocol.HMW)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 function_status = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &function_status_)));
          set_has_function_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_warning_level;
        break;
      }

      // optional int32 warning_level = 2;
      case 2: {
        if (tag == 16) {
         parse_warning_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &warning_level_)));
          set_has_warning_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_time_to_conllision;
        break;
      }

      // optional float time_to_conllision = 3;
      case 3: {
        if (tag == 29) {
         parse_time_to_conllision:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &time_to_conllision_)));
          set_has_time_to_conllision();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_object_type;
        break;
      }

      // optional int32 object_type = 4;
      case 4: {
        if (tag == 32) {
         parse_object_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &object_type_)));
          set_has_object_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_veh_id;
        break;
      }

      // optional int32 veh_id = 5;
      case 5: {
        if (tag == 40) {
         parse_veh_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &veh_id_)));
          set_has_veh_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:AdasOutputProtocol.HMW)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:AdasOutputProtocol.HMW)
  return false;
#undef DO_
}

void HMW::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:AdasOutputProtocol.HMW)
  // optional int32 function_status = 1;
  if (has_function_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->function_status(), output);
  }

  // optional int32 warning_level = 2;
  if (has_warning_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->warning_level(), output);
  }

  // optional float time_to_conllision = 3;
  if (has_time_to_conllision()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->time_to_conllision(), output);
  }

  // optional int32 object_type = 4;
  if (has_object_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->object_type(), output);
  }

  // optional int32 veh_id = 5;
  if (has_veh_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->veh_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:AdasOutputProtocol.HMW)
}

::google::protobuf::uint8* HMW::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:AdasOutputProtocol.HMW)
  // optional int32 function_status = 1;
  if (has_function_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->function_status(), target);
  }

  // optional int32 warning_level = 2;
  if (has_warning_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->warning_level(), target);
  }

  // optional float time_to_conllision = 3;
  if (has_time_to_conllision()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->time_to_conllision(), target);
  }

  // optional int32 object_type = 4;
  if (has_object_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->object_type(), target);
  }

  // optional int32 veh_id = 5;
  if (has_veh_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->veh_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AdasOutputProtocol.HMW)
  return target;
}

int HMW::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 function_status = 1;
    if (has_function_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->function_status());
    }

    // optional int32 warning_level = 2;
    if (has_warning_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->warning_level());
    }

    // optional float time_to_conllision = 3;
    if (has_time_to_conllision()) {
      total_size += 1 + 4;
    }

    // optional int32 object_type = 4;
    if (has_object_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->object_type());
    }

    // optional int32 veh_id = 5;
    if (has_veh_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->veh_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void HMW::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const HMW* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const HMW*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void HMW::MergeFrom(const HMW& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_function_status()) {
      set_function_status(from.function_status());
    }
    if (from.has_warning_level()) {
      set_warning_level(from.warning_level());
    }
    if (from.has_time_to_conllision()) {
      set_time_to_conllision(from.time_to_conllision());
    }
    if (from.has_object_type()) {
      set_object_type(from.object_type());
    }
    if (from.has_veh_id()) {
      set_veh_id(from.veh_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void HMW::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void HMW::CopyFrom(const HMW& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool HMW::IsInitialized() const {

  return true;
}

void HMW::Swap(HMW* other) {
  if (other != this) {
    std::swap(function_status_, other->function_status_);
    std::swap(warning_level_, other->warning_level_);
    std::swap(time_to_conllision_, other->time_to_conllision_);
    std::swap(object_type_, other->object_type_);
    std::swap(veh_id_, other->veh_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata HMW::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = HMW_descriptor_;
  metadata.reflection = HMW_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* FCW_FcwLevel_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FCW_FcwLevel_descriptor_;
}
bool FCW_FcwLevel_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const FCW_FcwLevel FCW::kFcwLevel_None;
const FCW_FcwLevel FCW::kFcwLevel_Warning;
const FCW_FcwLevel FCW::FcwLevel_MIN;
const FCW_FcwLevel FCW::FcwLevel_MAX;
const int FCW::FcwLevel_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int FCW::kFunctionStatusFieldNumber;
const int FCW::kWarningLevelFieldNumber;
const int FCW::kTimeToConllisionFieldNumber;
const int FCW::kObjectTypeFieldNumber;
const int FCW::kVehIdFieldNumber;
#endif  // !_MSC_VER

FCW::FCW()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AdasOutputProtocol.FCW)
}

void FCW::InitAsDefaultInstance() {
}

FCW::FCW(const FCW& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:AdasOutputProtocol.FCW)
}

void FCW::SharedCtor() {
  _cached_size_ = 0;
  function_status_ = 0;
  warning_level_ = 0;
  time_to_conllision_ = 0;
  object_type_ = 0;
  veh_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FCW::~FCW() {
  // @@protoc_insertion_point(destructor:AdasOutputProtocol.FCW)
  SharedDtor();
}

void FCW::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FCW::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FCW::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FCW_descriptor_;
}

const FCW& FCW::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_adas_5foutput_2eproto();
  return *default_instance_;
}

FCW* FCW::default_instance_ = NULL;

FCW* FCW::New() const {
  return new FCW;
}

void FCW::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<FCW*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(function_status_, veh_id_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FCW::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:AdasOutputProtocol.FCW)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 function_status = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &function_status_)));
          set_has_function_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_warning_level;
        break;
      }

      // optional int32 warning_level = 2;
      case 2: {
        if (tag == 16) {
         parse_warning_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &warning_level_)));
          set_has_warning_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_time_to_conllision;
        break;
      }

      // optional float time_to_conllision = 3;
      case 3: {
        if (tag == 29) {
         parse_time_to_conllision:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &time_to_conllision_)));
          set_has_time_to_conllision();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_object_type;
        break;
      }

      // optional int32 object_type = 4;
      case 4: {
        if (tag == 32) {
         parse_object_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &object_type_)));
          set_has_object_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_veh_id;
        break;
      }

      // optional int32 veh_id = 5;
      case 5: {
        if (tag == 40) {
         parse_veh_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &veh_id_)));
          set_has_veh_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:AdasOutputProtocol.FCW)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:AdasOutputProtocol.FCW)
  return false;
#undef DO_
}

void FCW::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:AdasOutputProtocol.FCW)
  // optional int32 function_status = 1;
  if (has_function_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->function_status(), output);
  }

  // optional int32 warning_level = 2;
  if (has_warning_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->warning_level(), output);
  }

  // optional float time_to_conllision = 3;
  if (has_time_to_conllision()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->time_to_conllision(), output);
  }

  // optional int32 object_type = 4;
  if (has_object_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->object_type(), output);
  }

  // optional int32 veh_id = 5;
  if (has_veh_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->veh_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:AdasOutputProtocol.FCW)
}

::google::protobuf::uint8* FCW::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:AdasOutputProtocol.FCW)
  // optional int32 function_status = 1;
  if (has_function_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->function_status(), target);
  }

  // optional int32 warning_level = 2;
  if (has_warning_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->warning_level(), target);
  }

  // optional float time_to_conllision = 3;
  if (has_time_to_conllision()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->time_to_conllision(), target);
  }

  // optional int32 object_type = 4;
  if (has_object_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->object_type(), target);
  }

  // optional int32 veh_id = 5;
  if (has_veh_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->veh_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AdasOutputProtocol.FCW)
  return target;
}

int FCW::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 function_status = 1;
    if (has_function_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->function_status());
    }

    // optional int32 warning_level = 2;
    if (has_warning_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->warning_level());
    }

    // optional float time_to_conllision = 3;
    if (has_time_to_conllision()) {
      total_size += 1 + 4;
    }

    // optional int32 object_type = 4;
    if (has_object_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->object_type());
    }

    // optional int32 veh_id = 5;
    if (has_veh_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->veh_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FCW::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FCW* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FCW*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FCW::MergeFrom(const FCW& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_function_status()) {
      set_function_status(from.function_status());
    }
    if (from.has_warning_level()) {
      set_warning_level(from.warning_level());
    }
    if (from.has_time_to_conllision()) {
      set_time_to_conllision(from.time_to_conllision());
    }
    if (from.has_object_type()) {
      set_object_type(from.object_type());
    }
    if (from.has_veh_id()) {
      set_veh_id(from.veh_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FCW::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FCW::CopyFrom(const FCW& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FCW::IsInitialized() const {

  return true;
}

void FCW::Swap(FCW* other) {
  if (other != this) {
    std::swap(function_status_, other->function_status_);
    std::swap(warning_level_, other->warning_level_);
    std::swap(time_to_conllision_, other->time_to_conllision_);
    std::swap(object_type_, other->object_type_);
    std::swap(veh_id_, other->veh_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FCW::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FCW_descriptor_;
  metadata.reflection = FCW_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* PCW_PcwLevel_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PCW_PcwLevel_descriptor_;
}
bool PCW_PcwLevel_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const PCW_PcwLevel PCW::kPcwLevel_None;
const PCW_PcwLevel PCW::kPcwLevel_Warning;
const PCW_PcwLevel PCW::PcwLevel_MIN;
const PCW_PcwLevel PCW::PcwLevel_MAX;
const int PCW::PcwLevel_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int PCW::kFunctionStatusFieldNumber;
const int PCW::kWarningLevelFieldNumber;
const int PCW::kTimeToConllisionFieldNumber;
const int PCW::kObjectTypeFieldNumber;
const int PCW::kPedIdFieldNumber;
#endif  // !_MSC_VER

PCW::PCW()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AdasOutputProtocol.PCW)
}

void PCW::InitAsDefaultInstance() {
}

PCW::PCW(const PCW& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:AdasOutputProtocol.PCW)
}

void PCW::SharedCtor() {
  _cached_size_ = 0;
  function_status_ = 0;
  warning_level_ = 0;
  time_to_conllision_ = 0;
  object_type_ = 0;
  ped_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PCW::~PCW() {
  // @@protoc_insertion_point(destructor:AdasOutputProtocol.PCW)
  SharedDtor();
}

void PCW::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PCW::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PCW::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PCW_descriptor_;
}

const PCW& PCW::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_adas_5foutput_2eproto();
  return *default_instance_;
}

PCW* PCW::default_instance_ = NULL;

PCW* PCW::New() const {
  return new PCW;
}

void PCW::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<PCW*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(function_status_, ped_id_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PCW::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:AdasOutputProtocol.PCW)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 function_status = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &function_status_)));
          set_has_function_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_warning_level;
        break;
      }

      // optional int32 warning_level = 2;
      case 2: {
        if (tag == 16) {
         parse_warning_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &warning_level_)));
          set_has_warning_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_time_to_conllision;
        break;
      }

      // optional float time_to_conllision = 3;
      case 3: {
        if (tag == 29) {
         parse_time_to_conllision:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &time_to_conllision_)));
          set_has_time_to_conllision();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_object_type;
        break;
      }

      // optional int32 object_type = 4;
      case 4: {
        if (tag == 32) {
         parse_object_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &object_type_)));
          set_has_object_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_ped_id;
        break;
      }

      // optional int32 ped_id = 5;
      case 5: {
        if (tag == 40) {
         parse_ped_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &ped_id_)));
          set_has_ped_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:AdasOutputProtocol.PCW)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:AdasOutputProtocol.PCW)
  return false;
#undef DO_
}

void PCW::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:AdasOutputProtocol.PCW)
  // optional int32 function_status = 1;
  if (has_function_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->function_status(), output);
  }

  // optional int32 warning_level = 2;
  if (has_warning_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->warning_level(), output);
  }

  // optional float time_to_conllision = 3;
  if (has_time_to_conllision()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->time_to_conllision(), output);
  }

  // optional int32 object_type = 4;
  if (has_object_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->object_type(), output);
  }

  // optional int32 ped_id = 5;
  if (has_ped_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->ped_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:AdasOutputProtocol.PCW)
}

::google::protobuf::uint8* PCW::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:AdasOutputProtocol.PCW)
  // optional int32 function_status = 1;
  if (has_function_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->function_status(), target);
  }

  // optional int32 warning_level = 2;
  if (has_warning_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->warning_level(), target);
  }

  // optional float time_to_conllision = 3;
  if (has_time_to_conllision()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->time_to_conllision(), target);
  }

  // optional int32 object_type = 4;
  if (has_object_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->object_type(), target);
  }

  // optional int32 ped_id = 5;
  if (has_ped_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->ped_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AdasOutputProtocol.PCW)
  return target;
}

int PCW::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 function_status = 1;
    if (has_function_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->function_status());
    }

    // optional int32 warning_level = 2;
    if (has_warning_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->warning_level());
    }

    // optional float time_to_conllision = 3;
    if (has_time_to_conllision()) {
      total_size += 1 + 4;
    }

    // optional int32 object_type = 4;
    if (has_object_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->object_type());
    }

    // optional int32 ped_id = 5;
    if (has_ped_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->ped_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PCW::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PCW* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PCW*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PCW::MergeFrom(const PCW& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_function_status()) {
      set_function_status(from.function_status());
    }
    if (from.has_warning_level()) {
      set_warning_level(from.warning_level());
    }
    if (from.has_time_to_conllision()) {
      set_time_to_conllision(from.time_to_conllision());
    }
    if (from.has_object_type()) {
      set_object_type(from.object_type());
    }
    if (from.has_ped_id()) {
      set_ped_id(from.ped_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PCW::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PCW::CopyFrom(const PCW& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PCW::IsInitialized() const {

  return true;
}

void PCW::Swap(PCW* other) {
  if (other != this) {
    std::swap(function_status_, other->function_status_);
    std::swap(warning_level_, other->warning_level_);
    std::swap(time_to_conllision_, other->time_to_conllision_);
    std::swap(object_type_, other->object_type_);
    std::swap(ped_id_, other->ped_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PCW::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PCW_descriptor_;
  metadata.reflection = PCW_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* LDW_LdwLevel_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LDW_LdwLevel_descriptor_;
}
bool LDW_LdwLevel_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const LDW_LdwLevel LDW::kLdwLevel_None;
const LDW_LdwLevel LDW::kLdwLevel_WarningLeftSide;
const LDW_LdwLevel LDW::kLdwLevel_WarningRightSide;
const LDW_LdwLevel LDW::LdwLevel_MIN;
const LDW_LdwLevel LDW::LdwLevel_MAX;
const int LDW::LdwLevel_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int LDW::kFunctionStatusFieldNumber;
const int LDW::kWarningLevelFieldNumber;
const int LDW::kLineCrossDistanceFieldNumber;
const int LDW::kObjectTypeFieldNumber;
const int LDW::kLineIdFieldNumber;
#endif  // !_MSC_VER

LDW::LDW()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AdasOutputProtocol.LDW)
}

void LDW::InitAsDefaultInstance() {
}

LDW::LDW(const LDW& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:AdasOutputProtocol.LDW)
}

void LDW::SharedCtor() {
  _cached_size_ = 0;
  function_status_ = 0;
  warning_level_ = 0;
  line_cross_distance_ = 0;
  object_type_ = 0;
  line_id_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LDW::~LDW() {
  // @@protoc_insertion_point(destructor:AdasOutputProtocol.LDW)
  SharedDtor();
}

void LDW::SharedDtor() {
  if (this != default_instance_) {
  }
}

void LDW::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LDW::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LDW_descriptor_;
}

const LDW& LDW::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_adas_5foutput_2eproto();
  return *default_instance_;
}

LDW* LDW::default_instance_ = NULL;

LDW* LDW::New() const {
  return new LDW;
}

void LDW::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<LDW*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 31) {
    ZR_(function_status_, line_id_);
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LDW::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:AdasOutputProtocol.LDW)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 function_status = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &function_status_)));
          set_has_function_status();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_warning_level;
        break;
      }

      // optional int32 warning_level = 2;
      case 2: {
        if (tag == 16) {
         parse_warning_level:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &warning_level_)));
          set_has_warning_level();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(29)) goto parse_line_cross_distance;
        break;
      }

      // optional float line_cross_distance = 3;
      case 3: {
        if (tag == 29) {
         parse_line_cross_distance:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &line_cross_distance_)));
          set_has_line_cross_distance();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(32)) goto parse_object_type;
        break;
      }

      // optional int32 object_type = 4;
      case 4: {
        if (tag == 32) {
         parse_object_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &object_type_)));
          set_has_object_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_line_id;
        break;
      }

      // optional int32 line_id = 5;
      case 5: {
        if (tag == 40) {
         parse_line_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &line_id_)));
          set_has_line_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:AdasOutputProtocol.LDW)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:AdasOutputProtocol.LDW)
  return false;
#undef DO_
}

void LDW::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:AdasOutputProtocol.LDW)
  // optional int32 function_status = 1;
  if (has_function_status()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->function_status(), output);
  }

  // optional int32 warning_level = 2;
  if (has_warning_level()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->warning_level(), output);
  }

  // optional float line_cross_distance = 3;
  if (has_line_cross_distance()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(3, this->line_cross_distance(), output);
  }

  // optional int32 object_type = 4;
  if (has_object_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->object_type(), output);
  }

  // optional int32 line_id = 5;
  if (has_line_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->line_id(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:AdasOutputProtocol.LDW)
}

::google::protobuf::uint8* LDW::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:AdasOutputProtocol.LDW)
  // optional int32 function_status = 1;
  if (has_function_status()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->function_status(), target);
  }

  // optional int32 warning_level = 2;
  if (has_warning_level()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->warning_level(), target);
  }

  // optional float line_cross_distance = 3;
  if (has_line_cross_distance()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(3, this->line_cross_distance(), target);
  }

  // optional int32 object_type = 4;
  if (has_object_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->object_type(), target);
  }

  // optional int32 line_id = 5;
  if (has_line_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->line_id(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AdasOutputProtocol.LDW)
  return target;
}

int LDW::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional int32 function_status = 1;
    if (has_function_status()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->function_status());
    }

    // optional int32 warning_level = 2;
    if (has_warning_level()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->warning_level());
    }

    // optional float line_cross_distance = 3;
    if (has_line_cross_distance()) {
      total_size += 1 + 4;
    }

    // optional int32 object_type = 4;
    if (has_object_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->object_type());
    }

    // optional int32 line_id = 5;
    if (has_line_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->line_id());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LDW::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LDW* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LDW*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LDW::MergeFrom(const LDW& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_function_status()) {
      set_function_status(from.function_status());
    }
    if (from.has_warning_level()) {
      set_warning_level(from.warning_level());
    }
    if (from.has_line_cross_distance()) {
      set_line_cross_distance(from.line_cross_distance());
    }
    if (from.has_object_type()) {
      set_object_type(from.object_type());
    }
    if (from.has_line_id()) {
      set_line_id(from.line_id());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LDW::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LDW::CopyFrom(const LDW& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LDW::IsInitialized() const {

  return true;
}

void LDW::Swap(LDW* other) {
  if (other != this) {
    std::swap(function_status_, other->function_status_);
    std::swap(warning_level_, other->warning_level_);
    std::swap(line_cross_distance_, other->line_cross_distance_);
    std::swap(object_type_, other->object_type_);
    std::swap(line_id_, other->line_id_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LDW::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LDW_descriptor_;
  metadata.reflection = LDW_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int WarningResult::kHmwFieldNumber;
const int WarningResult::kFcwFieldNumber;
const int WarningResult::kLdwFieldNumber;
const int WarningResult::kPcwFieldNumber;
const int WarningResult::kWarningTypeFieldNumber;
#endif  // !_MSC_VER

WarningResult::WarningResult()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AdasOutputProtocol.WarningResult)
}

void WarningResult::InitAsDefaultInstance() {
  hmw_ = const_cast< ::AdasOutputProtocol::HMW*>(&::AdasOutputProtocol::HMW::default_instance());
  fcw_ = const_cast< ::AdasOutputProtocol::FCW*>(&::AdasOutputProtocol::FCW::default_instance());
  ldw_ = const_cast< ::AdasOutputProtocol::LDW*>(&::AdasOutputProtocol::LDW::default_instance());
  pcw_ = const_cast< ::AdasOutputProtocol::PCW*>(&::AdasOutputProtocol::PCW::default_instance());
}

WarningResult::WarningResult(const WarningResult& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:AdasOutputProtocol.WarningResult)
}

void WarningResult::SharedCtor() {
  _cached_size_ = 0;
  hmw_ = NULL;
  fcw_ = NULL;
  ldw_ = NULL;
  pcw_ = NULL;
  warning_type_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

WarningResult::~WarningResult() {
  // @@protoc_insertion_point(destructor:AdasOutputProtocol.WarningResult)
  SharedDtor();
}

void WarningResult::SharedDtor() {
  if (this != default_instance_) {
    delete hmw_;
    delete fcw_;
    delete ldw_;
    delete pcw_;
  }
}

void WarningResult::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* WarningResult::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return WarningResult_descriptor_;
}

const WarningResult& WarningResult::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_adas_5foutput_2eproto();
  return *default_instance_;
}

WarningResult* WarningResult::default_instance_ = NULL;

WarningResult* WarningResult::New() const {
  return new WarningResult;
}

void WarningResult::Clear() {
  if (_has_bits_[0 / 32] & 31) {
    if (has_hmw()) {
      if (hmw_ != NULL) hmw_->::AdasOutputProtocol::HMW::Clear();
    }
    if (has_fcw()) {
      if (fcw_ != NULL) fcw_->::AdasOutputProtocol::FCW::Clear();
    }
    if (has_ldw()) {
      if (ldw_ != NULL) ldw_->::AdasOutputProtocol::LDW::Clear();
    }
    if (has_pcw()) {
      if (pcw_ != NULL) pcw_->::AdasOutputProtocol::PCW::Clear();
    }
    warning_type_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool WarningResult::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:AdasOutputProtocol.WarningResult)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .AdasOutputProtocol.HMW hmw = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_hmw()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_fcw;
        break;
      }

      // optional .AdasOutputProtocol.FCW fcw = 2;
      case 2: {
        if (tag == 18) {
         parse_fcw:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_fcw()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_ldw;
        break;
      }

      // optional .AdasOutputProtocol.LDW ldw = 3;
      case 3: {
        if (tag == 26) {
         parse_ldw:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_ldw()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_pcw;
        break;
      }

      // optional .AdasOutputProtocol.PCW pcw = 4;
      case 4: {
        if (tag == 34) {
         parse_pcw:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pcw()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(40)) goto parse_warning_type;
        break;
      }

      // optional int32 warning_type = 5;
      case 5: {
        if (tag == 40) {
         parse_warning_type:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &warning_type_)));
          set_has_warning_type();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:AdasOutputProtocol.WarningResult)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:AdasOutputProtocol.WarningResult)
  return false;
#undef DO_
}

void WarningResult::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:AdasOutputProtocol.WarningResult)
  // optional .AdasOutputProtocol.HMW hmw = 1;
  if (has_hmw()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->hmw(), output);
  }

  // optional .AdasOutputProtocol.FCW fcw = 2;
  if (has_fcw()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->fcw(), output);
  }

  // optional .AdasOutputProtocol.LDW ldw = 3;
  if (has_ldw()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->ldw(), output);
  }

  // optional .AdasOutputProtocol.PCW pcw = 4;
  if (has_pcw()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->pcw(), output);
  }

  // optional int32 warning_type = 5;
  if (has_warning_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->warning_type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:AdasOutputProtocol.WarningResult)
}

::google::protobuf::uint8* WarningResult::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:AdasOutputProtocol.WarningResult)
  // optional .AdasOutputProtocol.HMW hmw = 1;
  if (has_hmw()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->hmw(), target);
  }

  // optional .AdasOutputProtocol.FCW fcw = 2;
  if (has_fcw()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->fcw(), target);
  }

  // optional .AdasOutputProtocol.LDW ldw = 3;
  if (has_ldw()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->ldw(), target);
  }

  // optional .AdasOutputProtocol.PCW pcw = 4;
  if (has_pcw()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->pcw(), target);
  }

  // optional int32 warning_type = 5;
  if (has_warning_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->warning_type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AdasOutputProtocol.WarningResult)
  return target;
}

int WarningResult::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .AdasOutputProtocol.HMW hmw = 1;
    if (has_hmw()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->hmw());
    }

    // optional .AdasOutputProtocol.FCW fcw = 2;
    if (has_fcw()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->fcw());
    }

    // optional .AdasOutputProtocol.LDW ldw = 3;
    if (has_ldw()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->ldw());
    }

    // optional .AdasOutputProtocol.PCW pcw = 4;
    if (has_pcw()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pcw());
    }

    // optional int32 warning_type = 5;
    if (has_warning_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->warning_type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void WarningResult::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const WarningResult* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const WarningResult*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void WarningResult::MergeFrom(const WarningResult& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_hmw()) {
      mutable_hmw()->::AdasOutputProtocol::HMW::MergeFrom(from.hmw());
    }
    if (from.has_fcw()) {
      mutable_fcw()->::AdasOutputProtocol::FCW::MergeFrom(from.fcw());
    }
    if (from.has_ldw()) {
      mutable_ldw()->::AdasOutputProtocol::LDW::MergeFrom(from.ldw());
    }
    if (from.has_pcw()) {
      mutable_pcw()->::AdasOutputProtocol::PCW::MergeFrom(from.pcw());
    }
    if (from.has_warning_type()) {
      set_warning_type(from.warning_type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void WarningResult::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void WarningResult::CopyFrom(const WarningResult& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool WarningResult::IsInitialized() const {

  return true;
}

void WarningResult::Swap(WarningResult* other) {
  if (other != this) {
    std::swap(hmw_, other->hmw_);
    std::swap(fcw_, other->fcw_);
    std::swap(ldw_, other->ldw_);
    std::swap(pcw_, other->pcw_);
    std::swap(warning_type_, other->warning_type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata WarningResult::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = WarningResult_descriptor_;
  metadata.reflection = WarningResult_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int AdasOutput::kVersionFieldNumber;
const int AdasOutput::kFrameIdFieldNumber;
const int AdasOutput::kCameraFieldNumber;
const int AdasOutput::kImageFieldNumber;
const int AdasOutput::kGpsFieldNumber;
const int AdasOutput::kMotionFieldNumber;
const int AdasOutput::kVehiclesFieldNumber;
const int AdasOutput::kPedestriansFieldNumber;
const int AdasOutput::kLinesFieldNumber;
const int AdasOutput::kWarningResultFieldNumber;
#endif  // !_MSC_VER

AdasOutput::AdasOutput()
  : ::google::protobuf::Message() {
  SharedCtor();
  // @@protoc_insertion_point(constructor:AdasOutputProtocol.AdasOutput)
}

void AdasOutput::InitAsDefaultInstance() {
  camera_ = const_cast< ::AdasOutputProtocol::CameraInfo*>(&::AdasOutputProtocol::CameraInfo::default_instance());
  image_ = const_cast< ::AdasOutputProtocol::ImageFrame*>(&::AdasOutputProtocol::ImageFrame::default_instance());
  gps_ = const_cast< ::AdasOutputProtocol::GPS*>(&::AdasOutputProtocol::GPS::default_instance());
  motion_ = const_cast< ::AdasOutputProtocol::Motion*>(&::AdasOutputProtocol::Motion::default_instance());
  warning_result_ = const_cast< ::AdasOutputProtocol::WarningResult*>(&::AdasOutputProtocol::WarningResult::default_instance());
}

AdasOutput::AdasOutput(const AdasOutput& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:AdasOutputProtocol.AdasOutput)
}

void AdasOutput::SharedCtor() {
  _cached_size_ = 0;
  version_ = 0;
  frame_id_ = 0;
  camera_ = NULL;
  image_ = NULL;
  gps_ = NULL;
  motion_ = NULL;
  warning_result_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

AdasOutput::~AdasOutput() {
  // @@protoc_insertion_point(destructor:AdasOutputProtocol.AdasOutput)
  SharedDtor();
}

void AdasOutput::SharedDtor() {
  if (this != default_instance_) {
    delete camera_;
    delete image_;
    delete gps_;
    delete motion_;
    delete warning_result_;
  }
}

void AdasOutput::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AdasOutput::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AdasOutput_descriptor_;
}

const AdasOutput& AdasOutput::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_adas_5foutput_2eproto();
  return *default_instance_;
}

AdasOutput* AdasOutput::default_instance_ = NULL;

AdasOutput* AdasOutput::New() const {
  return new AdasOutput;
}

void AdasOutput::Clear() {
#define OFFSET_OF_FIELD_(f) (reinterpret_cast<char*>(      \
  &reinterpret_cast<AdasOutput*>(16)->f) - \
   reinterpret_cast<char*>(16))

#define ZR_(first, last) do {                              \
    size_t f = OFFSET_OF_FIELD_(first);                    \
    size_t n = OFFSET_OF_FIELD_(last) - f + sizeof(last);  \
    ::memset(&first, 0, n);                                \
  } while (0)

  if (_has_bits_[0 / 32] & 63) {
    ZR_(version_, frame_id_);
    if (has_camera()) {
      if (camera_ != NULL) camera_->::AdasOutputProtocol::CameraInfo::Clear();
    }
    if (has_image()) {
      if (image_ != NULL) image_->::AdasOutputProtocol::ImageFrame::Clear();
    }
    if (has_gps()) {
      if (gps_ != NULL) gps_->::AdasOutputProtocol::GPS::Clear();
    }
    if (has_motion()) {
      if (motion_ != NULL) motion_->::AdasOutputProtocol::Motion::Clear();
    }
  }
  if (has_warning_result()) {
    if (warning_result_ != NULL) warning_result_->::AdasOutputProtocol::WarningResult::Clear();
  }

#undef OFFSET_OF_FIELD_
#undef ZR_

  vehicles_.Clear();
  pedestrians_.Clear();
  lines_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool AdasOutput::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:AdasOutputProtocol.AdasOutput)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 version = 1;
      case 1: {
        if (tag == 8) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(16)) goto parse_frame_id;
        break;
      }

      // required int32 frame_id = 2;
      case 2: {
        if (tag == 16) {
         parse_frame_id:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &frame_id_)));
          set_has_frame_id();
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_camera;
        break;
      }

      // optional .AdasOutputProtocol.CameraInfo camera = 3;
      case 3: {
        if (tag == 26) {
         parse_camera:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_camera()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_image;
        break;
      }

      // optional .AdasOutputProtocol.ImageFrame image = 4;
      case 4: {
        if (tag == 34) {
         parse_image:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_image()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_gps;
        break;
      }

      // optional .AdasOutputProtocol.GPS gps = 5;
      case 5: {
        if (tag == 42) {
         parse_gps:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_gps()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_motion;
        break;
      }

      // optional .AdasOutputProtocol.Motion motion = 6;
      case 6: {
        if (tag == 50) {
         parse_motion:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_motion()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_vehicles;
        break;
      }

      // repeated .AdasOutputProtocol.Object vehicles = 7;
      case 7: {
        if (tag == 58) {
         parse_vehicles:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_vehicles()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(58)) goto parse_vehicles;
        if (input->ExpectTag(66)) goto parse_pedestrians;
        break;
      }

      // repeated .AdasOutputProtocol.Object pedestrians = 8;
      case 8: {
        if (tag == 66) {
         parse_pedestrians:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_pedestrians()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(66)) goto parse_pedestrians;
        if (input->ExpectTag(74)) goto parse_lines;
        break;
      }

      // repeated .AdasOutputProtocol.Line lines = 9;
      case 9: {
        if (tag == 74) {
         parse_lines:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_lines()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(74)) goto parse_lines;
        if (input->ExpectTag(82)) goto parse_warning_result;
        break;
      }

      // optional .AdasOutputProtocol.WarningResult warning_result = 10;
      case 10: {
        if (tag == 82) {
         parse_warning_result:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_warning_result()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:AdasOutputProtocol.AdasOutput)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:AdasOutputProtocol.AdasOutput)
  return false;
#undef DO_
}

void AdasOutput::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:AdasOutputProtocol.AdasOutput)
  // required int32 version = 1;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->version(), output);
  }

  // required int32 frame_id = 2;
  if (has_frame_id()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->frame_id(), output);
  }

  // optional .AdasOutputProtocol.CameraInfo camera = 3;
  if (has_camera()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->camera(), output);
  }

  // optional .AdasOutputProtocol.ImageFrame image = 4;
  if (has_image()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->image(), output);
  }

  // optional .AdasOutputProtocol.GPS gps = 5;
  if (has_gps()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->gps(), output);
  }

  // optional .AdasOutputProtocol.Motion motion = 6;
  if (has_motion()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->motion(), output);
  }

  // repeated .AdasOutputProtocol.Object vehicles = 7;
  for (int i = 0; i < this->vehicles_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->vehicles(i), output);
  }

  // repeated .AdasOutputProtocol.Object pedestrians = 8;
  for (int i = 0; i < this->pedestrians_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->pedestrians(i), output);
  }

  // repeated .AdasOutputProtocol.Line lines = 9;
  for (int i = 0; i < this->lines_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->lines(i), output);
  }

  // optional .AdasOutputProtocol.WarningResult warning_result = 10;
  if (has_warning_result()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->warning_result(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:AdasOutputProtocol.AdasOutput)
}

::google::protobuf::uint8* AdasOutput::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:AdasOutputProtocol.AdasOutput)
  // required int32 version = 1;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->version(), target);
  }

  // required int32 frame_id = 2;
  if (has_frame_id()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->frame_id(), target);
  }

  // optional .AdasOutputProtocol.CameraInfo camera = 3;
  if (has_camera()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->camera(), target);
  }

  // optional .AdasOutputProtocol.ImageFrame image = 4;
  if (has_image()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->image(), target);
  }

  // optional .AdasOutputProtocol.GPS gps = 5;
  if (has_gps()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->gps(), target);
  }

  // optional .AdasOutputProtocol.Motion motion = 6;
  if (has_motion()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->motion(), target);
  }

  // repeated .AdasOutputProtocol.Object vehicles = 7;
  for (int i = 0; i < this->vehicles_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->vehicles(i), target);
  }

  // repeated .AdasOutputProtocol.Object pedestrians = 8;
  for (int i = 0; i < this->pedestrians_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->pedestrians(i), target);
  }

  // repeated .AdasOutputProtocol.Line lines = 9;
  for (int i = 0; i < this->lines_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->lines(i), target);
  }

  // optional .AdasOutputProtocol.WarningResult warning_result = 10;
  if (has_warning_result()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->warning_result(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:AdasOutputProtocol.AdasOutput)
  return target;
}

int AdasOutput::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 version = 1;
    if (has_version()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->version());
    }

    // required int32 frame_id = 2;
    if (has_frame_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->frame_id());
    }

    // optional .AdasOutputProtocol.CameraInfo camera = 3;
    if (has_camera()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->camera());
    }

    // optional .AdasOutputProtocol.ImageFrame image = 4;
    if (has_image()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->image());
    }

    // optional .AdasOutputProtocol.GPS gps = 5;
    if (has_gps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->gps());
    }

    // optional .AdasOutputProtocol.Motion motion = 6;
    if (has_motion()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->motion());
    }

  }
  if (_has_bits_[9 / 32] & (0xffu << (9 % 32))) {
    // optional .AdasOutputProtocol.WarningResult warning_result = 10;
    if (has_warning_result()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->warning_result());
    }

  }
  // repeated .AdasOutputProtocol.Object vehicles = 7;
  total_size += 1 * this->vehicles_size();
  for (int i = 0; i < this->vehicles_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->vehicles(i));
  }

  // repeated .AdasOutputProtocol.Object pedestrians = 8;
  total_size += 1 * this->pedestrians_size();
  for (int i = 0; i < this->pedestrians_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->pedestrians(i));
  }

  // repeated .AdasOutputProtocol.Line lines = 9;
  total_size += 1 * this->lines_size();
  for (int i = 0; i < this->lines_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->lines(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AdasOutput::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const AdasOutput* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const AdasOutput*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void AdasOutput::MergeFrom(const AdasOutput& from) {
  GOOGLE_CHECK_NE(&from, this);
  vehicles_.MergeFrom(from.vehicles_);
  pedestrians_.MergeFrom(from.pedestrians_);
  lines_.MergeFrom(from.lines_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_version()) {
      set_version(from.version());
    }
    if (from.has_frame_id()) {
      set_frame_id(from.frame_id());
    }
    if (from.has_camera()) {
      mutable_camera()->::AdasOutputProtocol::CameraInfo::MergeFrom(from.camera());
    }
    if (from.has_image()) {
      mutable_image()->::AdasOutputProtocol::ImageFrame::MergeFrom(from.image());
    }
    if (from.has_gps()) {
      mutable_gps()->::AdasOutputProtocol::GPS::MergeFrom(from.gps());
    }
    if (from.has_motion()) {
      mutable_motion()->::AdasOutputProtocol::Motion::MergeFrom(from.motion());
    }
  }
  if (from._has_bits_[9 / 32] & (0xffu << (9 % 32))) {
    if (from.has_warning_result()) {
      mutable_warning_result()->::AdasOutputProtocol::WarningResult::MergeFrom(from.warning_result());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void AdasOutput::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AdasOutput::CopyFrom(const AdasOutput& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool AdasOutput::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_image()) {
    if (!this->image().IsInitialized()) return false;
  }
  if (has_gps()) {
    if (!this->gps().IsInitialized()) return false;
  }
  if (has_motion()) {
    if (!this->motion().IsInitialized()) return false;
  }
  if (!::google::protobuf::internal::AllAreInitialized(this->vehicles())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->pedestrians())) return false;
  if (!::google::protobuf::internal::AllAreInitialized(this->lines())) return false;
  return true;
}

void AdasOutput::Swap(AdasOutput* other) {
  if (other != this) {
    std::swap(version_, other->version_);
    std::swap(frame_id_, other->frame_id_);
    std::swap(camera_, other->camera_);
    std::swap(image_, other->image_);
    std::swap(gps_, other->gps_);
    std::swap(motion_, other->motion_);
    vehicles_.Swap(&other->vehicles_);
    pedestrians_.Swap(&other->pedestrians_);
    lines_.Swap(&other->lines_);
    std::swap(warning_result_, other->warning_result_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata AdasOutput::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AdasOutput_descriptor_;
  metadata.reflection = AdasOutput_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace AdasOutputProtocol

// @@protoc_insertion_point(global_scope)
